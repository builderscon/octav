// DO NOT EDIT. Automatically generated by hsup at Thu, 03 Mar 2016 12:57:14 JST
package octav

import (
	"encoding/json"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/builderscon/octav/octav/validator"
	"github.com/gorilla/mux"
	"golang.org/x/net/context"
)

type Server struct {
	*mux.Router
}

func Run(l string) error {
	return http.ListenAndServe(l, New())
}

func New() *Server {
	s := &Server{
		Router: mux.NewRouter(),
	}
	s.SetupRoutes()
	return s
}

func getInteger(v url.Values, f string) ([]int64, error) {
	x, ok := v[f]
	if !ok {
		return nil, nil
	}

	ret := make([]int64, len(x))
	for i, e := range x {
		p, err := strconv.ParseInt(e, 10, 64)
		if err != nil {
			return nil, err
		}
		ret[i] = p
	}

	return ret, nil
}

func httpCreateConference(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `post` {
		http.Error(w, `Not Found`, http.StatusNotFound)
	}

	var payload interface{}
	if err := json.NewDecoder(r.Body).Decode(payload); err != nil {
		http.Error(w, `Invalid input`, http.StatusInternalServerError)
		return
	}

	if err := validator.HTTPCreateConferenceRequest.Validate(payload); err != nil {
		http.Error(w, `Invalid input`, http.StatusInternalServerError)
		return
	}
	doCreateConference(context.Background(), w, r, payload)
}

func httpCreateRoom(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `post` {
		http.Error(w, `Not Found`, http.StatusNotFound)
	}

	var payload interface{}
	if err := json.NewDecoder(r.Body).Decode(payload); err != nil {
		http.Error(w, `Invalid input`, http.StatusInternalServerError)
		return
	}

	if err := validator.HTTPCreateRoomRequest.Validate(payload); err != nil {
		http.Error(w, `Invalid input`, http.StatusInternalServerError)
		return
	}
	doCreateRoom(context.Background(), w, r, payload)
}

func httpCreateSession(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `post` {
		http.Error(w, `Not Found`, http.StatusNotFound)
	}

	var payload interface{}
	if err := json.NewDecoder(r.Body).Decode(payload); err != nil {
		http.Error(w, `Invalid input`, http.StatusInternalServerError)
		return
	}

	if err := validator.HTTPCreateSessionRequest.Validate(payload); err != nil {
		http.Error(w, `Invalid input`, http.StatusInternalServerError)
		return
	}
	doCreateSession(context.Background(), w, r, payload)
}

func httpCreateUser(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `post` {
		http.Error(w, `Not Found`, http.StatusNotFound)
	}

	var payload interface{}
	if err := json.NewDecoder(r.Body).Decode(payload); err != nil {
		http.Error(w, `Invalid input`, http.StatusInternalServerError)
		return
	}

	if err := validator.HTTPCreateUserRequest.Validate(payload); err != nil {
		http.Error(w, `Invalid input`, http.StatusInternalServerError)
		return
	}
	doCreateUser(context.Background(), w, r, payload)
}

func httpCreateVenue(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `post` {
		http.Error(w, `Not Found`, http.StatusNotFound)
	}

	var payload *Venue
	if err := json.NewDecoder(r.Body).Decode(payload); err != nil {
		http.Error(w, `Invalid input`, http.StatusInternalServerError)
		return
	}

	if err := validator.HTTPCreateVenueRequest.Validate(payload); err != nil {
		http.Error(w, `Invalid input`, http.StatusInternalServerError)
		return
	}
	doCreateVenue(context.Background(), w, r, payload)
}

func httpListRooms(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `get` {
		http.Error(w, `Not Found`, http.StatusNotFound)
	}

	if err := r.ParseForm(); err != nil {
		http.Error(w, `Failed to process query/post form`, http.StatusInternalServerError)
		return
	}
	payload := make(map[string]interface{})
	{
		v := r.Form["venue-id"]
		switch len(v) {
		case 0:
		case 1:
			payload["venue-id"] = v[0]
		default:
			payload["venue-id"] = v
		}
	}

	{
		v := r.Form["lang"]
		switch len(v) {
		case 0:
		case 1:
			payload["lang"] = v[0]
		default:
			payload["lang"] = v
		}
	}

	if err := validator.HTTPListRoomsRequest.Validate(payload); err != nil {
		http.Error(w, `Invalid input`, http.StatusInternalServerError)
		return
	}
	doListRooms(context.Background(), w, r, payload)
}

func httpListVenues(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `get` {
		http.Error(w, `Not Found`, http.StatusNotFound)
	}

	if err := r.ParseForm(); err != nil {
		http.Error(w, `Failed to process query/post form`, http.StatusInternalServerError)
		return
	}
	payload := make(map[string]interface{})
	{
		v := r.Form["lang"]
		switch len(v) {
		case 0:
		case 1:
			payload["lang"] = v[0]
		default:
			payload["lang"] = v
		}
	}

	{
		v := r.Form["since"]
		switch len(v) {
		case 0:
		case 1:
			payload["since"] = v[0]
		default:
			payload["since"] = v
		}
	}

	if err := validator.HTTPListVenuesRequest.Validate(payload); err != nil {
		http.Error(w, `Invalid input`, http.StatusInternalServerError)
		return
	}
	doListVenues(context.Background(), w, r, payload)
}

func (s *Server) SetupRoutes() {
	r := s.Router
	r.HandleFunc(`/v1/conference/create`, httpCreateConference)
	r.HandleFunc(`/v1/room/create`, httpCreateRoom)
	r.HandleFunc(`/v1/room/list`, httpListRooms)
	r.HandleFunc(`/v1/session/create`, httpCreateSession)
	r.HandleFunc(`/v1/user/create`, httpCreateUser)
	r.HandleFunc(`/v1/venue/create`, httpCreateVenue)
	r.HandleFunc(`/v1/venue/list`, httpListVenues)
}
