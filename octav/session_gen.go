// Automatically generated by genmodel utility. DO NOT EDIT!
package octav

import (
	"encoding/json"
	"time"

	"github.com/builderscon/octav/octav/db"
	"github.com/builderscon/octav/octav/tools"
	"github.com/lestrrat/go-pdebug"
)

var _ = time.Time{}

func (v Session) GetPropNames() ([]string, error) {
	l, _ := v.L10N.GetPropNames()
	return append(l, "id", "conference_id", "room_id", "speaker_id", "title", "abstract", "memo", "starts_on", "duration", "material_level", "tags", "category", "spoken_language", "slide_language", "slide_subtitles", "slide_url", "video_url", "photo_permission", "video_permission", "has_interpretation", "status", "confirmed", "conference", "room", "speaker"), nil
}

func (v Session) GetPropValue(s string) (interface{}, error) {
	switch s {
	case "id":
		return v.ID, nil
	case "conference_id":
		return v.ConferenceID, nil
	case "room_id":
		return v.RoomID, nil
	case "speaker_id":
		return v.SpeakerID, nil
	case "title":
		return v.Title, nil
	case "abstract":
		return v.Abstract, nil
	case "memo":
		return v.Memo, nil
	case "starts_on":
		return v.StartsOn, nil
	case "duration":
		return v.Duration, nil
	case "material_level":
		return v.MaterialLevel, nil
	case "tags":
		return v.Tags, nil
	case "category":
		return v.Category, nil
	case "spoken_language":
		return v.SpokenLanguage, nil
	case "slide_language":
		return v.SlideLanguage, nil
	case "slide_subtitles":
		return v.SlideSubtitles, nil
	case "slide_url":
		return v.SlideURL, nil
	case "video_url":
		return v.VideoURL, nil
	case "photo_permission":
		return v.PhotoPermission, nil
	case "video_permission":
		return v.VideoPermission, nil
	case "has_interpretation":
		return v.HasInterpretation, nil
	case "status":
		return v.Status, nil
	case "confirmed":
		return v.Confirmed, nil
	case "conference":
		return v.Conference, nil
	case "room":
		return v.Room, nil
	case "speaker":
		return v.Speaker, nil
	default:
		return v.L10N.GetPropValue(s)
	}
}

func (v Session) MarshalJSON() ([]byte, error) {
	m := make(map[string]interface{})
	m["id"] = v.ID
	m["conference_id"] = v.ConferenceID
	m["room_id"] = v.RoomID
	m["speaker_id"] = v.SpeakerID
	m["title"] = v.Title
	m["abstract"] = v.Abstract
	m["memo"] = v.Memo
	m["starts_on"] = v.StartsOn
	m["duration"] = v.Duration
	m["material_level"] = v.MaterialLevel
	m["tags"] = v.Tags
	m["category"] = v.Category
	m["spoken_language"] = v.SpokenLanguage
	m["slide_language"] = v.SlideLanguage
	m["slide_subtitles"] = v.SlideSubtitles
	m["slide_url"] = v.SlideURL
	m["video_url"] = v.VideoURL
	m["photo_permission"] = v.PhotoPermission
	m["video_permission"] = v.VideoPermission
	m["has_interpretation"] = v.HasInterpretation
	m["status"] = v.Status
	m["confirmed"] = v.Confirmed
	m["conference"] = v.Conference
	m["room"] = v.Room
	m["speaker"] = v.Speaker
	buf, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	return tools.MarshalJSONWithL10N(buf, v.L10N)
}

func (v *Session) UnmarshalJSON(data []byte) error {
	m := make(map[string]interface{})
	if err := json.Unmarshal(data, &m); err != nil {
		return err
	}

	if jv, ok := m["id"]; ok {
		switch jv.(type) {
		case string:
			v.ID = jv.(string)
			delete(m, "id")
		default:
			return ErrInvalidFieldType{Field: "id"}
		}
	}

	if jv, ok := m["conference_id"]; ok {
		switch jv.(type) {
		case string:
			v.ConferenceID = jv.(string)
			delete(m, "conference_id")
		default:
			return ErrInvalidFieldType{Field: "conference_id"}
		}
	}

	if jv, ok := m["room_id"]; ok {
		switch jv.(type) {
		case string:
			v.RoomID = jv.(string)
			delete(m, "room_id")
		default:
			return ErrInvalidFieldType{Field: "room_id"}
		}
	}

	if jv, ok := m["speaker_id"]; ok {
		switch jv.(type) {
		case string:
			v.SpeakerID = jv.(string)
			delete(m, "speaker_id")
		default:
			return ErrInvalidFieldType{Field: "speaker_id"}
		}
	}

	if jv, ok := m["title"]; ok {
		switch jv.(type) {
		case string:
			v.Title = jv.(string)
			delete(m, "title")
		default:
			return ErrInvalidFieldType{Field: "title"}
		}
	}

	if jv, ok := m["abstract"]; ok {
		switch jv.(type) {
		case string:
			v.Abstract = jv.(string)
			delete(m, "abstract")
		default:
			return ErrInvalidFieldType{Field: "abstract"}
		}
	}

	if jv, ok := m["memo"]; ok {
		switch jv.(type) {
		case string:
			v.Memo = jv.(string)
			delete(m, "memo")
		default:
			return ErrInvalidFieldType{Field: "memo"}
		}
	}

	if jv, ok := m["starts_on"]; ok {
		switch jv.(type) {
		case time.Time:
			v.StartsOn = jv.(time.Time)
			delete(m, "starts_on")
		case string:
		default:
pdebug.Printf("%#v", jv)
			return ErrInvalidFieldType{Field: "starts_on"}
		}
	}

	if jv, ok := m["duration"]; ok {
		switch jv.(type) {
		case float64:
			v.Duration = int(jv.(float64))
			delete(m, "duration")
		default:
			return ErrInvalidFieldType{Field: "duration"}
		}
	}

	if jv, ok := m["material_level"]; ok {
		switch jv.(type) {
		case string:
			v.MaterialLevel = jv.(string)
			delete(m, "material_level")
		default:
			return ErrInvalidFieldType{Field: "material_level"}
		}
	}

	v.Tags = TagString("")
/*
	if jv, ok := m["tags"]; ok {
		switch jv.(type) {
		case TagString:
			v.Tags = jv.(TagString)
			delete(m, "tags")
		default:
			return ErrInvalidFieldType{Field: "tags"}
		}
	}
*/

	if jv, ok := m["category"]; ok {
		switch jv.(type) {
		case string:
			v.Category = jv.(string)
			delete(m, "category")
		default:
			return ErrInvalidFieldType{Field: "category"}
		}
	}

	if jv, ok := m["spoken_language"]; ok {
		switch jv.(type) {
		case string:
			v.SpokenLanguage = jv.(string)
			delete(m, "spoken_language")
		default:
			return ErrInvalidFieldType{Field: "spoken_language"}
		}
	}

	if jv, ok := m["slide_language"]; ok {
		switch jv.(type) {
		case string:
			v.SlideLanguage = jv.(string)
			delete(m, "slide_language")
		default:
			return ErrInvalidFieldType{Field: "slide_language"}
		}
	}

	if jv, ok := m["slide_subtitles"]; ok {
		switch jv.(type) {
		case string:
			v.SlideSubtitles = jv.(string)
			delete(m, "slide_subtitles")
		default:
			return ErrInvalidFieldType{Field: "slide_subtitles"}
		}
	}

	if jv, ok := m["slide_url"]; ok {
		switch jv.(type) {
		case string:
			v.SlideURL = jv.(string)
			delete(m, "slide_url")
		default:
			return ErrInvalidFieldType{Field: "slide_url"}
		}
	}

	if jv, ok := m["video_url"]; ok {
		switch jv.(type) {
		case string:
			v.VideoURL = jv.(string)
			delete(m, "video_url")
		default:
			return ErrInvalidFieldType{Field: "video_url"}
		}
	}

	if jv, ok := m["photo_permission"]; ok {
		switch jv.(type) {
		case string:
			v.PhotoPermission = jv.(string)
			delete(m, "photo_permission")
		default:
			return ErrInvalidFieldType{Field: "photo_permission"}
		}
	}

	if jv, ok := m["video_permission"]; ok {
		switch jv.(type) {
		case string:
			v.VideoPermission = jv.(string)
			delete(m, "video_permission")
		default:
			return ErrInvalidFieldType{Field: "video_permission"}
		}
	}

	if jv, ok := m["has_interpretation"]; ok {
		switch jv.(type) {
		case bool:
			v.HasInterpretation = jv.(bool)
			delete(m, "has_interpretation")
		default:
			return ErrInvalidFieldType{Field: "has_interpretation"}
		}
	}

	if jv, ok := m["status"]; ok {
		switch jv.(type) {
		case string:
			v.Status = jv.(string)
			delete(m, "status")
		default:
			return ErrInvalidFieldType{Field: "status"}
		}
	}

	if jv, ok := m["confirmed"]; ok {
		switch jv.(type) {
		case bool:
			v.Confirmed = jv.(bool)
			delete(m, "confirmed")
		default:
			return ErrInvalidFieldType{Field: "confirmed"}
		}
	}

	if jv, ok := m["conference"]; ok {
		switch jv.(type) {
		case *Conference:
			v.Conference = jv.(*Conference)
			delete(m, "conference")
		case nil:
		default:
			return ErrInvalidFieldType{Field: "conference"}
		}
	}

	if jv, ok := m["room"]; ok {
		switch jv.(type) {
		case *Room:
			v.Room = jv.(*Room)
			delete(m, "room")
		case nil:
		default:
			return ErrInvalidFieldType{Field: "room"}
		}
	}

	if jv, ok := m["speaker"]; ok {
		switch jv.(type) {
		case *User:
			v.Speaker = jv.(*User)
			delete(m, "speaker")
		case nil:
		default:
			return ErrInvalidFieldType{Field: "speaker"}
		}
	}
	return nil
}

func (v *Session) Load(tx *db.Tx, id string) error {
	vdb := db.Session{}
	if err := vdb.LoadByEID(tx, id); err != nil {
		return err
	}

	if err := v.FromRow(vdb); err != nil {
		return err
	}
	if err := v.LoadLocalizedFields(tx); err != nil {
		return err
	}
	return nil
}

func (v *Session) LoadLocalizedFields(tx *db.Tx) error {
	ls, err := db.LoadLocalizedStringsForParent(tx, v.ID, "Session")
	if err != nil {
		return err
	}

	if len(ls) > 0 {
		v.L10N = tools.LocalizedFields{}
		for _, l := range ls {
			v.L10N.Set(l.Language, l.Name, l.Localized)
		}
	}
	return nil
}

func (v *Session) FromRow(vdb db.Session) error {
	v.ID = vdb.EID
	v.ConferenceID = vdb.ConferenceID
	if vdb.RoomID.Valid {
		v.RoomID = vdb.RoomID.String
	}
	v.SpeakerID = vdb.SpeakerID
	if vdb.Title.Valid {
		v.Title = vdb.Title.String
	}
	if vdb.Abstract.Valid {
		v.Abstract = vdb.Abstract.String
	}
	if vdb.Memo.Valid {
		v.Memo = vdb.Memo.String
	}
	if vdb.StartsOn.Valid {
		v.StartsOn = vdb.StartsOn.Time
	}
	v.Duration = vdb.Duration
	if vdb.MaterialLevel.Valid {
		v.MaterialLevel = vdb.MaterialLevel.String
	}
	if vdb.Tags.Valid {
		v.Tags = TagString(vdb.Tags.String)
	}
	if vdb.Category.Valid {
		v.Category = vdb.Category.String
	}
	if vdb.SpokenLanguage.Valid {
		v.SpokenLanguage = vdb.SpokenLanguage.String
	}
	if vdb.SlideLanguage.Valid {
		v.SlideLanguage = vdb.SlideLanguage.String
	}
	if vdb.SlideSubtitles.Valid {
		v.SlideSubtitles = vdb.SlideSubtitles.String
	}
	if vdb.SlideURL.Valid {
		v.SlideURL = vdb.SlideURL.String
	}
	if vdb.VideoURL.Valid {
		v.VideoURL = vdb.VideoURL.String
	}
	if vdb.PhotoPermission.Valid {
		v.PhotoPermission = vdb.PhotoPermission.String
	}
	if vdb.VideoPermission.Valid {
		v.VideoPermission = vdb.VideoPermission.String
	}
	v.HasInterpretation = vdb.HasInterpretation
	v.Status = vdb.Status
	v.Confirmed = vdb.Confirmed
	return nil
}

func (v *Session) ToRow(vdb *db.Session) error {
	vdb.EID = v.ID
	vdb.ConferenceID = v.ConferenceID
	vdb.RoomID.Valid = true
	vdb.RoomID.String = v.RoomID
	vdb.SpeakerID = v.SpeakerID
	vdb.Title.Valid = true
	vdb.Title.String = v.Title
	vdb.Abstract.Valid = true
	vdb.Abstract.String = v.Abstract
	vdb.Memo.Valid = true
	vdb.Memo.String = v.Memo
	vdb.StartsOn.Valid = true
	vdb.StartsOn.Time = v.StartsOn
	vdb.Duration = v.Duration
	vdb.MaterialLevel.Valid = true
	vdb.MaterialLevel.String = v.MaterialLevel
	vdb.Tags.Valid = true
	vdb.Tags.String = string(v.Tags)
	vdb.Category.Valid = true
	vdb.Category.String = v.Category
	vdb.SpokenLanguage.Valid = true
	vdb.SpokenLanguage.String = v.SpokenLanguage
	vdb.SlideLanguage.Valid = true
	vdb.SlideLanguage.String = v.SlideLanguage
	vdb.SlideSubtitles.Valid = true
	vdb.SlideSubtitles.String = v.SlideSubtitles
	vdb.SlideURL.Valid = true
	vdb.SlideURL.String = v.SlideURL
	vdb.VideoURL.Valid = true
	vdb.VideoURL.String = v.VideoURL
	vdb.PhotoPermission.Valid = true
	vdb.PhotoPermission.String = v.PhotoPermission
	vdb.VideoPermission.Valid = true
	vdb.VideoPermission.String = v.VideoPermission
	vdb.HasInterpretation = v.HasInterpretation
	vdb.Status = v.Status
	vdb.Confirmed = v.Confirmed
	return nil
}

func (v *Session) Update(tx *db.Tx) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("Session.Update (%s)", v.ID).BindError(&err)
		defer g.End()
	}

	vdb := db.Session{}
	v.ToRow(&vdb)
	if err := vdb.Update(tx); err != nil {
		return err
	}

	return v.L10N.Foreach(func(l, k, x string) error {
		ls := db.LocalizedString{
			ParentType: "Session",
			ParentID:   v.ID,
			Language:   l,
			Name:       k,
			Localized:  x,
		}
		return ls.Upsert(tx)
	})
}

func (v *Session) Delete(tx *db.Tx) error {
	if pdebug.Enabled {
		g := pdebug.Marker("Session.Delete (%s)", v.ID)
		defer g.End()
	}

	vdb := db.Session{EID: v.ID}
	if err := vdb.Delete(tx); err != nil {
		return err
	}
	if err := db.DeleteLocalizedStringsForParent(tx, v.ID, "Session"); err != nil {
		return err
	}
	return nil
}

func (v *SessionList) Load(tx *db.Tx, since string, limit int) error {
	vdbl := db.SessionList{}
	if err := vdbl.LoadSinceEID(tx, since, limit); err != nil {
		return err
	}
	res := make([]Session, len(vdbl))
	for i, vdb := range vdbl {
		v := Session{}
		if err := v.FromRow(vdb); err != nil {
			return err
		}
		if err := v.LoadLocalizedFields(tx); err != nil {
			return err
		}
		res[i] = v
	}
	*v = res
	return nil
}
