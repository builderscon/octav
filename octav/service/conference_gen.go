package service

// Automatically generated by genmodel utility. DO NOT EDIT!

import (
	"sync"
	"time"

	"github.com/builderscon/octav/octav/db"
	"github.com/builderscon/octav/octav/internal/errors"
	"github.com/builderscon/octav/octav/model"
	"github.com/lestrrat/go-pdebug"
)

var _ = time.Time{}

var conferenceSvc ConferenceSvc
var conferenceOnce sync.Once

func Conference() *ConferenceSvc {
	conferenceOnce.Do(conferenceSvc.Init)
	return &conferenceSvc
}

func (v *ConferenceSvc) LookupFromPayload(tx *db.Tx, m *model.Conference, payload model.LookupConferenceRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("service.Conference.LookupFromPayload").BindError(&err)
		defer g.End()
	}
	if err = v.Lookup(tx, m, payload.ID); err != nil {
		return errors.Wrap(err, "failed to load model.Conference from database")
	}
	if err := v.Decorate(tx, m, payload.TrustedCall, payload.Lang.String); err != nil {
		return errors.Wrap(err, "failed to load associated data for model.Conference from database")
	}
	return nil
}

func (v *ConferenceSvc) Lookup(tx *db.Tx, m *model.Conference, id string) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("service.Conference.Lookup").BindError(&err)
		defer g.End()
	}

	r := model.Conference{}
	if err = r.Load(tx, id); err != nil {
		return errors.Wrap(err, "failed to load model.Conference from database")
	}
	*m = r
	return nil
}

// Create takes in the transaction, the incoming payload, and a reference to
// a database row. The database row is initialized/populated so that the
// caller can use it afterwards.
func (v *ConferenceSvc) Create(tx *db.Tx, vdb *db.Conference, payload model.CreateConferenceRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("service.Conference.Create").BindError(&err)
		defer g.End()
	}

	if err := v.populateRowForCreate(vdb, payload); err != nil {
		return err
	}

	if err := vdb.Create(tx); err != nil {
		return err
	}

	if err := payload.L10N.CreateLocalizedStrings(tx, "Conference", vdb.EID); err != nil {
		return err
	}
	return nil
}

func (v *ConferenceSvc) Update(tx *db.Tx, vdb *db.Conference, payload model.UpdateConferenceRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("service.Conference.Update (%s)", vdb.EID).BindError(&err)
		defer g.End()
	}

	if vdb.EID == "" {
		return errors.New("vdb.EID is required (did you forget to call vdb.Load(tx) before hand?)")
	}

	if err := v.populateRowForUpdate(vdb, payload); err != nil {
		return err
	}

	if err := vdb.Update(tx); err != nil {
		return err
	}

	return payload.L10N.Foreach(func(l, k, x string) error {
		if pdebug.Enabled {
			pdebug.Printf("Updating l10n string for '%s' (%s)", k, l)
		}
		ls := db.LocalizedString{
			ParentType: "Conference",
			ParentID:   vdb.EID,
			Language:   l,
			Name:       k,
			Localized:  x,
		}
		return ls.Upsert(tx)
	})
}

func (v *ConferenceSvc) ReplaceL10NStrings(tx *db.Tx, m *model.Conference, lang string) error {
	if pdebug.Enabled {
		g := pdebug.Marker("service.Conference.ReplaceL10NStrings lang = %s", lang)
		defer g.End()
	}
	switch lang {
	case "", "en":
		if len(m.Title) > 0 && len(m.Description) > 0 && len(m.CFPLeadText) > 0 && len(m.CFPPreSubmitInstructions) > 0 && len(m.CFPPostSubmitInstructions) > 0 && len(m.SubTitle) > 0 {
			return nil
		}
		for _, extralang := range []string{`ja`} {
			rows, err := tx.Query(`SELECT oid, parent_id, parent_type, name, language, localized FROM localized_strings WHERE parent_type = ? AND parent_id = ? AND language = ?`, "Conference", m.ID, extralang)
			if err != nil {
				if errors.IsSQLNoRows(err) {
					break
				}
				return errors.Wrap(err, `failed to excute query`)
			}

			var l db.LocalizedString
			for rows.Next() {
				if err := l.Scan(rows); err != nil {
					return err
				}
				if len(l.Localized) == 0 {
					continue
				}
				switch l.Name {
				case "title":
					if len(m.Title) == 0 {
						if pdebug.Enabled {
							pdebug.Printf("Replacing for key 'title' (fallback en -> %s", l.Language)
						}
						m.Title = l.Localized
					}
				case "description":
					if len(m.Description) == 0 {
						if pdebug.Enabled {
							pdebug.Printf("Replacing for key 'description' (fallback en -> %s", l.Language)
						}
						m.Description = l.Localized
					}
				case "cfp_lead_text":
					if len(m.CFPLeadText) == 0 {
						if pdebug.Enabled {
							pdebug.Printf("Replacing for key 'cfp_lead_text' (fallback en -> %s", l.Language)
						}
						m.CFPLeadText = l.Localized
					}
				case "cfp_pre_submit_instructions":
					if len(m.CFPPreSubmitInstructions) == 0 {
						if pdebug.Enabled {
							pdebug.Printf("Replacing for key 'cfp_pre_submit_instructions' (fallback en -> %s", l.Language)
						}
						m.CFPPreSubmitInstructions = l.Localized
					}
				case "cfp_post_submit_instructions":
					if len(m.CFPPostSubmitInstructions) == 0 {
						if pdebug.Enabled {
							pdebug.Printf("Replacing for key 'cfp_post_submit_instructions' (fallback en -> %s", l.Language)
						}
						m.CFPPostSubmitInstructions = l.Localized
					}
				case "sub_title":
					if len(m.SubTitle) == 0 {
						if pdebug.Enabled {
							pdebug.Printf("Replacing for key 'sub_title' (fallback en -> %s", l.Language)
						}
						m.SubTitle = l.Localized
					}
				}
			}
		}
		return nil
	case "all":
		rows, err := tx.Query(`SELECT oid, parent_id, parent_type, name, language, localized FROM localized_strings WHERE parent_type = ? AND parent_id = ?`, "Conference", m.ID)
		if err != nil {
			return err
		}

		var l db.LocalizedString
		for rows.Next() {
			if err := l.Scan(rows); err != nil {
				return err
			}
			if len(l.Localized) == 0 {
				continue
			}
			if pdebug.Enabled {
				pdebug.Printf("Adding key '%s#%s'", l.Name, l.Language)
			}
			m.LocalizedFields.Set(l.Language, l.Name, l.Localized)
		}
	default:
		rows, err := tx.Query(`SELECT oid, parent_id, parent_type, name, language, localized FROM localized_strings WHERE parent_type = ? AND parent_id = ? AND language = ?`, "Conference", m.ID, lang)
		if err != nil {
			return err
		}

		var l db.LocalizedString
		for rows.Next() {
			if err := l.Scan(rows); err != nil {
				return err
			}
			if len(l.Localized) == 0 {
				continue
			}

			switch l.Name {
			case "title":
				if pdebug.Enabled {
					pdebug.Printf("Replacing for key 'title'")
				}
				m.Title = l.Localized
			case "description":
				if pdebug.Enabled {
					pdebug.Printf("Replacing for key 'description'")
				}
				m.Description = l.Localized
			case "cfp_lead_text":
				if pdebug.Enabled {
					pdebug.Printf("Replacing for key 'cfp_lead_text'")
				}
				m.CFPLeadText = l.Localized
			case "cfp_pre_submit_instructions":
				if pdebug.Enabled {
					pdebug.Printf("Replacing for key 'cfp_pre_submit_instructions'")
				}
				m.CFPPreSubmitInstructions = l.Localized
			case "cfp_post_submit_instructions":
				if pdebug.Enabled {
					pdebug.Printf("Replacing for key 'cfp_post_submit_instructions'")
				}
				m.CFPPostSubmitInstructions = l.Localized
			case "sub_title":
				if pdebug.Enabled {
					pdebug.Printf("Replacing for key 'sub_title'")
				}
				m.SubTitle = l.Localized
			}
		}
	}
	return nil
}

func (v *ConferenceSvc) Delete(tx *db.Tx, id string) error {
	if pdebug.Enabled {
		g := pdebug.Marker("Conference.Delete (%s)", id)
		defer g.End()
	}

	vdb := db.Conference{EID: id}
	if err := vdb.Delete(tx); err != nil {
		return err
	}
	if err := db.DeleteLocalizedStringsForParent(tx, id, "Conference"); err != nil {
		return err
	}
	return nil
}

func (v *ConferenceSvc) LoadList(tx *db.Tx, vdbl *db.ConferenceList, since string, limit int) error {
	return vdbl.LoadSinceEID(tx, since, limit)
}
