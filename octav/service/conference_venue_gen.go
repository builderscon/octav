package service

// Automatically generated by genmodel utility. DO NOT EDIT!

import (
	"context"
	"database/sql"
	"sync"
	"time"

	"github.com/builderscon/octav/octav/cache"

	"github.com/builderscon/octav/octav/db"
	"github.com/builderscon/octav/octav/internal/errors"
	"github.com/builderscon/octav/octav/model"
	"github.com/lestrrat/go-pdebug"
)

var _ = time.Time{}
var _ = cache.WithExpires(time.Minute)
var _ = context.Background
var _ = errors.Wrap
var _ = model.ConferenceVenue{}
var _ = db.ConferenceVenue{}
var _ = sql.ErrNoRows
var _ = pdebug.Enabled

var conferenceVenueSvc ConferenceVenueSvc
var conferenceVenueOnce sync.Once

func ConferenceVenue() *ConferenceVenueSvc {
	conferenceVenueOnce.Do(conferenceVenueSvc.Init)
	return &conferenceVenueSvc
}

// Create takes in the transaction, the incoming payload, and a reference to
// a database row. The database row is initialized/populated so that the
// caller can use it afterwards.
func (v *ConferenceVenueSvc) Create(ctx context.Context, tx *sql.Tx, vdb *db.ConferenceVenue, payload *model.CreateConferenceVenueRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("service.ConferenceVenue.Create").BindError(&err)
		defer g.End()
	}

	if err := v.populateRowForCreate(vdb, payload); err != nil {
		return errors.Wrap(err, `failed to populate row`)
	}

	if err := vdb.Create(tx, payload.DatabaseOptions...); err != nil {
		return errors.Wrap(err, `failed to insert into database`)
	}

	if err := v.PostCreateHook(ctx, tx, vdb); err != nil {
		return errors.Wrap(err, `post create hook failed`)
	}
	return nil
}
