package octav

// DO NOT EDIT. Automatically generated by hsup
import (
	"bytes"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"sync"

	"github.com/builderscon/octav/octav/model"
	"github.com/builderscon/octav/octav/validator"
	"github.com/gorilla/mux"
	"github.com/lestrrat/go-pdebug"
	"github.com/lestrrat/go-urlenc"
	"golang.org/x/net/context"
)

const MaxPostSize = (1 << 20) * 2

var _ = json.Decoder{}
var _ = urlenc.Marshal
var transportJSONBufferPool = sync.Pool{
	New: allocTransportJSONBuffer,
}

func allocTransportJSONBuffer() interface{} {
	return &bytes.Buffer{}
}

func getTransportJSONBuffer() *bytes.Buffer {
	return transportJSONBufferPool.Get().(*bytes.Buffer)
}

func releaseTransportJSONBuffer(buf *bytes.Buffer) {
	buf.Reset()
	transportJSONBufferPool.Put(buf)
}

type Server struct {
	*mux.Router
}

// NewContext creates a cteonxt.Context object from the request.
// If you are using appengine, for example, you probably want to set this
// function to something that create a context, and then sets
// the appengine context to it so it can be referred to later.
var NewContext func(*http.Request) context.Context = func(r *http.Request) context.Context {
	return context.Background()
}

func Run(l string) error {
	s := New()
	return http.ListenAndServe(l, s.makeHandler())
}

func New() *Server {
	s := &Server{
		Router: mux.NewRouter(),
	}
	s.SetupRoutes()
	return s
}

var httpError func(http.ResponseWriter, string, int, error) = defaultHTTPError

func defaultHTTPError(w http.ResponseWriter, message string, st int, err error) {
	if pdebug.Enabled {
		if err == nil {
			pdebug.Printf("HTTP Error %s", message)
		} else {
			pdebug.Printf("HTTP Error %s: %s", message, err)
		}
	}
	http.Error(w, http.StatusText(st), st)
}

func getInteger(v url.Values, f string) ([]int64, error) {
	x, ok := v[f]
	if !ok {
		return nil, nil
	}

	ret := make([]int64, len(x))
	for i, e := range x {
		p, err := strconv.ParseInt(e, 10, 64)
		if err != nil {
			return nil, err
		}
		ret[i] = p
	}

	return ret, nil
}

type HandlerWithContext func(context.Context, http.ResponseWriter, *http.Request)

func httpWithContext(h HandlerWithContext) http.HandlerFunc {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		h(NewContext(r), w, r)
	})
}

func (s *Server) makeHandler() http.Handler {
	var h http.Handler
	h = s
	h = mwset.Wrap(h)
	return h
}

func httpAddConferenceAdmin(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpAddConferenceAdmin")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.AddConferenceAdminRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPAddConferenceAdminRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doAddConferenceAdmin(ctx, w, r, payload)
}

func httpAddConferenceDates(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpAddConferenceDates")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.AddConferenceDatesRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPAddConferenceDatesRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doAddConferenceDates(ctx, w, r, payload)
}

func httpAddConferenceSeriesAdmin(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpAddConferenceSeriesAdmin")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.AddConferenceSeriesAdminRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPAddConferenceSeriesAdminRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doAddConferenceSeriesAdmin(ctx, w, r, payload)
}

func httpAddConferenceVenue(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpAddConferenceVenue")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.AddConferenceVenueRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPAddConferenceVenueRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doAddConferenceVenue(ctx, w, r, payload)
}

func httpAddFeaturedSpeaker(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpAddFeaturedSpeaker")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.AddFeaturedSpeakerRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPAddFeaturedSpeakerRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doAddFeaturedSpeaker(ctx, w, r, payload)
}

func httpAddSessionType(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpAddSessionType")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.AddSessionTypeRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPAddSessionTypeRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doAddSessionType(ctx, w, r, payload)
}

func httpAddSponsor(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpAddSponsor")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.AddSponsorRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPAddSponsorRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doAddSponsor(ctx, w, r, payload)
}

func httpCreateConference(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateConference")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.CreateConferenceRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateConferenceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateConference(ctx, w, r, payload)
}

func httpCreateConferenceSeries(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateConferenceSeries")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.CreateConferenceSeriesRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateConferenceSeriesRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateConferenceSeries(ctx, w, r, payload)
}

func httpCreateQuestion(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateQuestion")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.CreateQuestionRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateQuestionRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateQuestion(ctx, w, r, payload)
}

func httpCreateRoom(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateRoom")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.CreateRoomRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateRoomRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateRoom(ctx, w, r, payload)
}

func httpCreateSession(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateSession")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.CreateSessionRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateSessionRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateSession(ctx, w, r, payload)
}

func httpCreateSessionSurveyResponse(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateSessionSurveyResponse")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.CreateSessionSurveyResponseRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateSessionSurveyResponseRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateSessionSurveyResponse(ctx, w, r, payload)
}

func httpCreateUser(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateUser")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.CreateUserRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateUserRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateUser(ctx, w, r, payload)
}

func httpCreateVenue(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateVenue")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.CreateVenueRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateVenueRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateVenue(ctx, w, r, payload)
}

func httpDeleteConference(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteConference")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteConferenceRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteConferenceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteConference(ctx, w, r, payload)
}

func httpDeleteConferenceAdmin(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteConferenceAdmin")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteConferenceAdminRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteConferenceAdminRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteConferenceAdmin(ctx, w, r, payload)
}

func httpDeleteConferenceDates(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteConferenceDates")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteConferenceDatesRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteConferenceDatesRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteConferenceDates(ctx, w, r, payload)
}

func httpDeleteConferenceSeries(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteConferenceSeries")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteConferenceSeriesRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteConferenceSeriesRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteConferenceSeries(ctx, w, r, payload)
}

func httpDeleteConferenceVenue(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteConferenceVenue")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteConferenceVenueRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteConferenceVenueRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteConferenceVenue(ctx, w, r, payload)
}

func httpDeleteFeaturedSpeaker(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteFeaturedSpeaker")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteFeaturedSpeakerRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteFeaturedSpeakerRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteFeaturedSpeaker(ctx, w, r, payload)
}

func httpDeleteQuestion(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteQuestion")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteQuestionRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteQuestionRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteQuestion(ctx, w, r, payload)
}

func httpDeleteRoom(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteRoom")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteRoomRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteRoomRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteRoom(ctx, w, r, payload)
}

func httpDeleteSession(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteSession")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteSessionRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteSessionRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteSession(ctx, w, r, payload)
}

func httpDeleteSessionType(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteSessionType")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteSessionTypeRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteSessionTypeRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteSessionType(ctx, w, r, payload)
}

func httpDeleteSponsor(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteSponsor")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteSponsorRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteSponsorRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteSponsor(ctx, w, r, payload)
}

func httpDeleteUser(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteUser")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteUserRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteUserRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteUser(ctx, w, r, payload)
}

func httpDeleteVenue(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteVenue")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteVenueRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteVenueRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteVenue(ctx, w, r, payload)
}

func httpListConference(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListConference")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.ListConferenceRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListConferenceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListConference(ctx, w, r, payload)
}

func httpListConferenceSeries(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListConferenceSeries")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.ListConferenceSeriesRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListConferenceSeriesRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListConferenceSeries(ctx, w, r, payload)
}

func httpListConferencesByOrganizer(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListConferencesByOrganizer")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.ListConferencesByOrganizerRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListConferencesByOrganizerRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListConferencesByOrganizer(ctx, w, r, payload)
}

func httpListFeaturedSpeakers(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListFeaturedSpeakers")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.ListFeaturedSpeakersRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListFeaturedSpeakersRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListFeaturedSpeakers(ctx, w, r, payload)
}

func httpListQuestion(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListQuestion")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.ListQuestionRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListQuestionRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListQuestion(ctx, w, r, payload)
}

func httpListRoom(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListRoom")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.ListRoomRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListRoomRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListRoom(ctx, w, r, payload)
}

func httpListSessionTypesByConference(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListSessionTypesByConference")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.ListSessionTypesByConferenceRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListSessionTypesByConferenceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListSessionTypesByConference(ctx, w, r, payload)
}

func httpListSessions(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListSessions")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.ListSessionsRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListSessionsRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListSessions(ctx, w, r, payload)
}

func httpListSponsors(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListSponsors")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.ListSponsorsRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListSponsorsRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListSponsors(ctx, w, r, payload)
}

func httpListUser(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListUser")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.ListUserRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListUserRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListUser(ctx, w, r, payload)
}

func httpListVenue(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListVenue")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.ListVenueRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListVenueRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListVenue(ctx, w, r, payload)
}

func httpLookupConference(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupConference")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.LookupConferenceRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupConferenceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupConference(ctx, w, r, payload)
}

func httpLookupConferenceBySlug(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupConferenceBySlug")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.LookupConferenceBySlugRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupConferenceBySlugRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupConferenceBySlug(ctx, w, r, payload)
}

func httpLookupFeaturedSpeaker(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupFeaturedSpeaker")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.LookupFeaturedSpeakerRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupFeaturedSpeakerRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupFeaturedSpeaker(ctx, w, r, payload)
}

func httpLookupRoom(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupRoom")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.LookupRoomRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupRoomRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupRoom(ctx, w, r, payload)
}

func httpLookupSession(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupSession")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.LookupSessionRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupSessionRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupSession(ctx, w, r, payload)
}

func httpLookupSessionType(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupSessionType")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.LookupSessionTypeRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupSessionTypeRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupSessionType(ctx, w, r, payload)
}

func httpLookupSponsor(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupSponsor")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.LookupSponsorRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupSponsorRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupSponsor(ctx, w, r, payload)
}

func httpLookupUser(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupUser")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.LookupUserRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupUserRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupUser(ctx, w, r, payload)
}

func httpLookupUserByAuthUserID(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupUserByAuthUserID")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.LookupUserByAuthUserIDRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupUserByAuthUserIDRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupUserByAuthUserID(ctx, w, r, payload)
}

func httpLookupVenue(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupVenue")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `get` {
		w.Header().Set("Allow", "get")
		httpError(w, `Method was `+r.Method+`, expected get`, http.StatusNotFound, nil)
		return
	}

	var payload model.LookupVenueRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupVenueRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupVenue(ctx, w, r, payload)
}

func httpUpdateConference(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateConference")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateConferenceRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	case strings.HasPrefix(ct, "multipart/"):
		if err := r.ParseMultipartForm(MaxPostSize); err != nil {
			httpError(w, `Invalid multipart data`, http.StatusInternalServerError, err)
			return
		}
		vals, ok := r.MultipartForm.Value["payload"]
		if ok && len(vals) > 0 {
			if _, err := jsonbuf.WriteString(vals[0]); err != nil {
				httpError(w, `Failed to read payload`, http.StatusInternalServerError, err)
				return
			}
		}
		payload.MultipartForm = r.MultipartForm
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateConferenceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateConference(ctx, w, r, payload)
}

func httpUpdateFeaturedSpeaker(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateFeaturedSpeaker")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateFeaturedSpeakerRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateFeaturedSpeakerRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateFeaturedSpeaker(ctx, w, r, payload)
}

func httpUpdateRoom(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateRoom")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateRoomRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateRoomRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateRoom(ctx, w, r, payload)
}

func httpUpdateSession(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateSession")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateSessionRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateSessionRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateSession(ctx, w, r, payload)
}

func httpUpdateSessionType(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateSessionType")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateSessionTypeRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateSessionTypeRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateSessionType(ctx, w, r, payload)
}

func httpUpdateSponsor(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateSponsor")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateSponsorRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	case strings.HasPrefix(ct, "multipart/"):
		if err := r.ParseMultipartForm(MaxPostSize); err != nil {
			httpError(w, `Invalid multipart data`, http.StatusInternalServerError, err)
			return
		}
		vals, ok := r.MultipartForm.Value["payload"]
		if ok && len(vals) > 0 {
			if _, err := jsonbuf.WriteString(vals[0]); err != nil {
				httpError(w, `Failed to read payload`, http.StatusInternalServerError, err)
				return
			}
		}
		payload.MultipartForm = r.MultipartForm
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateSponsorRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateSponsor(ctx, w, r, payload)
}

func httpUpdateUser(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateUser")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateUserRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateUserRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateUser(ctx, w, r, payload)
}

func httpUpdateVenue(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateVenue")
		defer g.End()
	}
	if strings.ToLower(r.Method) != `post` {
		w.Header().Set("Allow", "post")
		httpError(w, `Method was `+r.Method+`, expected post`, http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateVenueRequest
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
		defer r.Body.Close()
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateVenueRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateVenue(ctx, w, r, payload)
}

func (s *Server) SetupRoutes() {
	r := s.Router
	r.HandleFunc(`/v1/conference/admin/add`, httpWithContext(httpWithBasicAuth(httpAddConferenceAdmin)))
	r.HandleFunc(`/v1/conference/admin/delete`, httpWithContext(httpWithBasicAuth(httpDeleteConferenceAdmin)))
	r.HandleFunc(`/v1/conference/create`, httpWithContext(httpWithBasicAuth(httpCreateConference)))
	r.HandleFunc(`/v1/conference/dates/add`, httpWithContext(httpWithBasicAuth(httpAddConferenceDates)))
	r.HandleFunc(`/v1/conference/dates/delete`, httpWithContext(httpDeleteConferenceDates))
	r.HandleFunc(`/v1/conference/delete`, httpWithContext(httpWithBasicAuth(httpDeleteConference)))
	r.HandleFunc(`/v1/conference/list`, httpWithContext(httpWithOptionalBasicAuth(httpListConference)))
	r.HandleFunc(`/v1/conference/list_by_organizer`, httpWithContext(httpWithOptionalBasicAuth(httpListConferencesByOrganizer)))
	r.HandleFunc(`/v1/conference/lookup`, httpWithContext(httpLookupConference))
	r.HandleFunc(`/v1/conference/lookup_by_slug`, httpWithContext(httpLookupConferenceBySlug))
	r.HandleFunc(`/v1/conference/session_type/add`, httpWithContext(httpWithBasicAuth(httpAddSessionType)))
	r.HandleFunc(`/v1/conference/update`, httpWithContext(httpWithBasicAuth(httpUpdateConference)))
	r.HandleFunc(`/v1/conference/venue/add`, httpWithContext(httpWithBasicAuth(httpAddConferenceVenue)))
	r.HandleFunc(`/v1/conference/venue/delete`, httpWithContext(httpWithBasicAuth(httpDeleteConferenceVenue)))
	r.HandleFunc(`/v1/conference_series/admin/add`, httpWithContext(httpWithBasicAuth(httpAddConferenceSeriesAdmin)))
	r.HandleFunc(`/v1/conference_series/create`, httpWithContext(httpWithBasicAuth(httpCreateConferenceSeries)))
	r.HandleFunc(`/v1/conference_series/delete`, httpWithContext(httpWithBasicAuth(httpDeleteConferenceSeries)))
	r.HandleFunc(`/v1/conference_series/list`, httpWithContext(httpWithOptionalBasicAuth(httpListConferenceSeries)))
	r.HandleFunc(`/v1/featured_speaker/add`, httpWithContext(httpWithBasicAuth(httpAddFeaturedSpeaker)))
	r.HandleFunc(`/v1/featured_speaker/delete`, httpWithContext(httpWithBasicAuth(httpDeleteFeaturedSpeaker)))
	r.HandleFunc(`/v1/featured_speaker/list`, httpWithContext(httpWithOptionalBasicAuth(httpListFeaturedSpeakers)))
	r.HandleFunc(`/v1/featured_speaker/lookup`, httpWithContext(httpWithBasicAuth(httpLookupFeaturedSpeaker)))
	r.HandleFunc(`/v1/featured_speaker/update`, httpWithContext(httpWithBasicAuth(httpUpdateFeaturedSpeaker)))
	r.HandleFunc(`/v1/question/create`, httpWithContext(httpWithBasicAuth(httpCreateQuestion)))
	r.HandleFunc(`/v1/question/delete`, httpWithContext(httpWithBasicAuth(httpDeleteQuestion)))
	r.HandleFunc(`/v1/question/list`, httpWithContext(httpWithOptionalBasicAuth(httpListQuestion)))
	r.HandleFunc(`/v1/room/create`, httpWithContext(httpWithBasicAuth(httpCreateRoom)))
	r.HandleFunc(`/v1/room/delete`, httpWithContext(httpWithBasicAuth(httpDeleteRoom)))
	r.HandleFunc(`/v1/room/list`, httpWithContext(httpWithOptionalBasicAuth(httpListRoom)))
	r.HandleFunc(`/v1/room/lookup`, httpWithContext(httpLookupRoom))
	r.HandleFunc(`/v1/room/update`, httpWithContext(httpWithBasicAuth(httpUpdateRoom)))
	r.HandleFunc(`/v1/session/create`, httpWithContext(httpWithBasicAuth(httpCreateSession)))
	r.HandleFunc(`/v1/session/delete`, httpWithContext(httpWithBasicAuth(httpDeleteSession)))
	r.HandleFunc(`/v1/session/list`, httpWithContext(httpWithOptionalBasicAuth(httpListSessions)))
	r.HandleFunc(`/v1/session/lookup`, httpWithContext(httpWithOptionalBasicAuth(httpLookupSession)))
	r.HandleFunc(`/v1/session/update`, httpWithContext(httpWithBasicAuth(httpUpdateSession)))
	r.HandleFunc(`/v1/session_type/delete`, httpWithContext(httpWithBasicAuth(httpDeleteSessionType)))
	r.HandleFunc(`/v1/session_type/list`, httpWithContext(httpWithOptionalBasicAuth(httpListSessionTypesByConference)))
	r.HandleFunc(`/v1/session_type/lookup`, httpWithContext(httpWithOptionalBasicAuth(httpLookupSessionType)))
	r.HandleFunc(`/v1/session_type/update`, httpWithContext(httpWithBasicAuth(httpUpdateSessionType)))
	r.HandleFunc(`/v1/sponsor/add`, httpWithContext(httpWithBasicAuth(httpAddSponsor)))
	r.HandleFunc(`/v1/sponsor/delete`, httpWithContext(httpWithBasicAuth(httpDeleteSponsor)))
	r.HandleFunc(`/v1/sponsor/list`, httpWithContext(httpWithOptionalBasicAuth(httpListSponsors)))
	r.HandleFunc(`/v1/sponsor/lookup`, httpWithContext(httpWithOptionalBasicAuth(httpLookupSponsor)))
	r.HandleFunc(`/v1/sponsor/update`, httpWithContext(httpWithBasicAuth(httpUpdateSponsor)))
	r.HandleFunc(`/v1/survey_session_response/create`, httpWithContext(httpWithBasicAuth(httpCreateSessionSurveyResponse)))
	r.HandleFunc(`/v1/user/create`, httpWithContext(httpWithBasicAuth(httpCreateUser)))
	r.HandleFunc(`/v1/user/delete`, httpWithContext(httpWithBasicAuth(httpDeleteUser)))
	r.HandleFunc(`/v1/user/list`, httpWithContext(httpWithOptionalBasicAuth(httpListUser)))
	r.HandleFunc(`/v1/user/lookup`, httpWithContext(httpWithOptionalBasicAuth(httpLookupUser)))
	r.HandleFunc(`/v1/user/lookup_user_by_auth_user_id`, httpWithContext(httpWithOptionalBasicAuth(httpLookupUserByAuthUserID)))
	r.HandleFunc(`/v1/user/update`, httpWithContext(httpWithBasicAuth(httpUpdateUser)))
	r.HandleFunc(`/v1/venue/create`, httpWithContext(httpWithBasicAuth(httpCreateVenue)))
	r.HandleFunc(`/v1/venue/delete`, httpWithContext(httpWithBasicAuth(httpDeleteVenue)))
	r.HandleFunc(`/v1/venue/list`, httpWithContext(httpWithOptionalBasicAuth(httpListVenue)))
	r.HandleFunc(`/v1/venue/lookup`, httpWithContext(httpLookupVenue))
	r.HandleFunc(`/v1/venue/update`, httpWithContext(httpWithBasicAuth(httpUpdateVenue)))
}
