package octav

// DO NOT EDIT. Automatically generated by hsup
import (
	"bytes"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"sync"

	"context"
	"github.com/builderscon/octav/octav/model"
	"github.com/builderscon/octav/octav/validator"
	"github.com/gorilla/mux"
	"github.com/lestrrat/go-pdebug"
	"github.com/lestrrat/go-urlenc"
	"io/ioutil"
)

const MaxPostSize = (1 << 20) * 2

var _ = json.Decoder{}
var _ = urlenc.Marshal
var bbPool = sync.Pool{
	New: allocBytesBuffer,
}

func allocBytesBuffer() interface{} {
	return &bytes.Buffer{}
}

func getBytesBuffer() *bytes.Buffer {
	return bbPool.Get().(*bytes.Buffer)
}

func releaseBytesBuffer(buf *bytes.Buffer) {
	buf.Reset()
	bbPool.Put(buf)
}

type Server struct {
	*mux.Router
}

// NewContext creates a cteonxt.Context object from the request.
// If you are using appengine, for example, you probably want to set this
// function to something that create a context, and then sets
// the appengine context to it so it can be referred to later.
var NewContext func(*http.Request) context.Context = func(r *http.Request) context.Context {
	return r.Context()
}

func Run(l string) error {
	s := New()
	return http.ListenAndServe(l, s.makeHandler())
}

func New() *Server {
	s := &Server{
		Router: mux.NewRouter(),
	}
	s.SetupRoutes()
	return s
}

var httpError func(http.ResponseWriter, string, int, error) = defaultHTTPError

func defaultHTTPError(w http.ResponseWriter, message string, st int, err error) {
	if pdebug.Enabled {
		if err == nil {
			pdebug.Printf("HTTP Error %s", message)
		} else {
			pdebug.Printf("HTTP Error %s: %s", message, err)
		}
	}
	http.Error(w, http.StatusText(st), st)
}

func getInteger(v url.Values, f string) ([]int64, error) {
	x, ok := v[f]
	if !ok {
		return nil, nil
	}

	ret := make([]int64, len(x))
	for i, e := range x {
		p, err := strconv.ParseInt(e, 10, 64)
		if err != nil {
			return nil, err
		}
		ret[i] = p
	}

	return ret, nil
}

type HandlerWithContext func(context.Context, http.ResponseWriter, *http.Request)

func httpWithContext(h HandlerWithContext) http.HandlerFunc {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		h(NewContext(r), w, r)
		defer io.Copy(ioutil.Discard, r.Body)
	})
}

func (s *Server) makeHandler() http.Handler {
	var h http.Handler
	h = s
	h = mwset.Wrap(h)
	return h
}

func httpAddConferenceAdmin(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpAddConferenceAdmin")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.AddConferenceAdminRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPAddConferenceAdminRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doAddConferenceAdmin(ctx, w, r, &payload)
}

func httpAddConferenceCredential(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpAddConferenceCredential")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.AddConferenceCredentialRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPAddConferenceCredentialRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doAddConferenceCredential(ctx, w, r, &payload)
}

func httpAddConferenceDate(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpAddConferenceDate")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.CreateConferenceDateRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPAddConferenceDateRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doAddConferenceDate(ctx, w, r, &payload)
}

func httpAddConferenceSeriesAdmin(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpAddConferenceSeriesAdmin")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.AddConferenceSeriesAdminRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPAddConferenceSeriesAdminRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doAddConferenceSeriesAdmin(ctx, w, r, &payload)
}

func httpAddConferenceStaff(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpAddConferenceStaff")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.AddConferenceStaffRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPAddConferenceStaffRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doAddConferenceStaff(ctx, w, r, &payload)
}

func httpAddConferenceVenue(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpAddConferenceVenue")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.AddConferenceVenueRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPAddConferenceVenueRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doAddConferenceVenue(ctx, w, r, &payload)
}

func httpAddFeaturedSpeaker(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpAddFeaturedSpeaker")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.AddFeaturedSpeakerRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPAddFeaturedSpeakerRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doAddFeaturedSpeaker(ctx, w, r, &payload)
}

func httpAddSessionType(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpAddSessionType")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.AddSessionTypeRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPAddSessionTypeRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doAddSessionType(ctx, w, r, &payload)
}

func httpAddSponsor(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpAddSponsor")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.AddSponsorRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPAddSponsorRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doAddSponsor(ctx, w, r, &payload)
}

func httpConfirmTemporaryEmail(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpConfirmTemporaryEmail")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.ConfirmTemporaryEmailRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPConfirmTemporaryEmailRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doConfirmTemporaryEmail(ctx, w, r, &payload)
}

func httpCreateBlogEntry(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateBlogEntry")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.CreateBlogEntryRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateBlogEntryRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateBlogEntry(ctx, w, r, &payload)
}

func httpCreateClientSession(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateClientSession")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.CreateClientSessionRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateClientSessionRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateClientSession(ctx, w, r, &payload)
}

func httpCreateConference(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateConference")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.CreateConferenceRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateConferenceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateConference(ctx, w, r, &payload)
}

func httpCreateConferenceSeries(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateConferenceSeries")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.CreateConferenceSeriesRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateConferenceSeriesRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateConferenceSeries(ctx, w, r, &payload)
}

func httpCreateExternalResource(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateExternalResource")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.CreateExternalResourceRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateExternalResourceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateExternalResource(ctx, w, r, &payload)
}

func httpCreateQuestion(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateQuestion")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.CreateQuestionRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateQuestionRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateQuestion(ctx, w, r, &payload)
}

func httpCreateRoom(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateRoom")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.CreateRoomRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateRoomRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateRoom(ctx, w, r, &payload)
}

func httpCreateSession(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateSession")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.CreateSessionRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateSessionRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateSession(ctx, w, r, &payload)
}

func httpCreateSessionSurveyResponse(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateSessionSurveyResponse")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.CreateSessionSurveyResponseRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateSessionSurveyResponseRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateSessionSurveyResponse(ctx, w, r, &payload)
}

func httpCreateTemporaryEmail(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateTemporaryEmail")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.CreateTemporaryEmailRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateTemporaryEmailRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateTemporaryEmail(ctx, w, r, &payload)
}

func httpCreateTrack(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateTrack")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.CreateTrackRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateTrackRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateTrack(ctx, w, r, &payload)
}

func httpCreateUser(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateUser")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.CreateUserRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateUserRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateUser(ctx, w, r, &payload)
}

func httpCreateVenue(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpCreateVenue")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.CreateVenueRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateVenueRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doCreateVenue(ctx, w, r, &payload)
}

func httpDeleteBlogEntry(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteBlogEntry")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteBlogEntryRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteBlogEntryRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteBlogEntry(ctx, w, r, &payload)
}

func httpDeleteConference(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteConference")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteConferenceRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteConferenceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteConference(ctx, w, r, &payload)
}

func httpDeleteConferenceAdmin(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteConferenceAdmin")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteConferenceAdminRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteConferenceAdminRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteConferenceAdmin(ctx, w, r, &payload)
}

func httpDeleteConferenceDate(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteConferenceDate")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteConferenceDateRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteConferenceDateRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteConferenceDate(ctx, w, r, &payload)
}

func httpDeleteConferenceSeries(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteConferenceSeries")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteConferenceSeriesRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteConferenceSeriesRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteConferenceSeries(ctx, w, r, &payload)
}

func httpDeleteConferenceStaff(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteConferenceStaff")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteConferenceStaffRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteConferenceStaffRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteConferenceStaff(ctx, w, r, &payload)
}

func httpDeleteConferenceVenue(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteConferenceVenue")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteConferenceVenueRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteConferenceVenueRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteConferenceVenue(ctx, w, r, &payload)
}

func httpDeleteExternalResource(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteExternalResource")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteExternalResourceRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteExternalResourceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteExternalResource(ctx, w, r, &payload)
}

func httpDeleteFeaturedSpeaker(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteFeaturedSpeaker")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteFeaturedSpeakerRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteFeaturedSpeakerRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteFeaturedSpeaker(ctx, w, r, &payload)
}

func httpDeleteQuestion(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteQuestion")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteQuestionRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteQuestionRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteQuestion(ctx, w, r, &payload)
}

func httpDeleteRoom(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteRoom")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteRoomRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteRoomRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteRoom(ctx, w, r, &payload)
}

func httpDeleteSession(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteSession")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteSessionRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteSessionRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteSession(ctx, w, r, &payload)
}

func httpDeleteSessionType(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteSessionType")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteSessionTypeRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteSessionTypeRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteSessionType(ctx, w, r, &payload)
}

func httpDeleteSponsor(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteSponsor")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteSponsorRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteSponsorRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteSponsor(ctx, w, r, &payload)
}

func httpDeleteTrack(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteTrack")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteTrackRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteTrackRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteTrack(ctx, w, r, &payload)
}

func httpDeleteUser(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteUser")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteUserRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteUserRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteUser(ctx, w, r, &payload)
}

func httpDeleteVenue(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpDeleteVenue")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.DeleteVenueRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteVenueRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doDeleteVenue(ctx, w, r, &payload)
}

func httpGetConferenceSchedule(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpGetConferenceSchedule")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.GetConferenceScheduleRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPGetConferenceScheduleRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doGetConferenceSchedule(ctx, w, r, &payload)
}

func httpHealthCheck(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpHealthCheck")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	doHealthCheck(ctx, w, r)
}

func httpListBlogEntries(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListBlogEntries")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.ListBlogEntriesRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListBlogEntriesRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListBlogEntries(ctx, w, r, &payload)
}

func httpListConference(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListConference")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.ListConferenceRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListConferenceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListConference(ctx, w, r, &payload)
}

func httpListConferenceAdmin(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListConferenceAdmin")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.ListConferenceAdminRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListConferenceAdminRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListConferenceAdmin(ctx, w, r, &payload)
}

func httpListConferenceDate(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListConferenceDate")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.ListConferenceDateRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListConferenceDateRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListConferenceDate(ctx, w, r, &payload)
}

func httpListConferenceSeries(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListConferenceSeries")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.ListConferenceSeriesRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListConferenceSeriesRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListConferenceSeries(ctx, w, r, &payload)
}

func httpListConferenceStaff(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListConferenceStaff")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.ListConferenceStaffRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListConferenceStaffRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListConferenceStaff(ctx, w, r, &payload)
}

func httpListConferencesByOrganizer(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListConferencesByOrganizer")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.ListConferencesByOrganizerRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListConferencesByOrganizerRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListConferencesByOrganizer(ctx, w, r, &payload)
}

func httpListExternalResource(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListExternalResource")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.ListExternalResourceRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListExternalResourceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListExternalResource(ctx, w, r, &payload)
}

func httpListFeaturedSpeakers(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListFeaturedSpeakers")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.ListFeaturedSpeakersRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListFeaturedSpeakersRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListFeaturedSpeakers(ctx, w, r, &payload)
}

func httpListQuestion(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListQuestion")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.ListQuestionRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListQuestionRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListQuestion(ctx, w, r, &payload)
}

func httpListRoom(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListRoom")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.ListRoomRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListRoomRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListRoom(ctx, w, r, &payload)
}

func httpListSessionTypesByConference(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListSessionTypesByConference")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.ListSessionTypesByConferenceRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListSessionTypesByConferenceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListSessionTypesByConference(ctx, w, r, &payload)
}

func httpListSessions(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListSessions")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.ListSessionsRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListSessionsRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListSessions(ctx, w, r, &payload)
}

func httpListSponsors(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListSponsors")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.ListSponsorsRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListSponsorsRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListSponsors(ctx, w, r, &payload)
}

func httpListUser(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListUser")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.ListUserRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListUserRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListUser(ctx, w, r, &payload)
}

func httpListVenue(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpListVenue")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.ListVenueRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListVenueRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doListVenue(ctx, w, r, &payload)
}

func httpLookupBlogEntry(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupBlogEntry")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.LookupBlogEntryRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupBlogEntryRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupBlogEntry(ctx, w, r, &payload)
}

func httpLookupConference(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupConference")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.LookupConferenceRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupConferenceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupConference(ctx, w, r, &payload)
}

func httpLookupConferenceBySlug(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupConferenceBySlug")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.LookupConferenceBySlugRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupConferenceBySlugRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupConferenceBySlug(ctx, w, r, &payload)
}

func httpLookupConferenceSeries(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupConferenceSeries")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.LookupConferenceSeriesRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupConferenceSeriesRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupConferenceSeries(ctx, w, r, &payload)
}

func httpLookupExternalResource(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupExternalResource")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.LookupExternalResourceRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupExternalResourceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupExternalResource(ctx, w, r, &payload)
}

func httpLookupFeaturedSpeaker(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupFeaturedSpeaker")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.LookupFeaturedSpeakerRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupFeaturedSpeakerRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupFeaturedSpeaker(ctx, w, r, &payload)
}

func httpLookupRoom(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupRoom")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.LookupRoomRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupRoomRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupRoom(ctx, w, r, &payload)
}

func httpLookupSession(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupSession")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.LookupSessionRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupSessionRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupSession(ctx, w, r, &payload)
}

func httpLookupSessionType(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupSessionType")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.LookupSessionTypeRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupSessionTypeRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupSessionType(ctx, w, r, &payload)
}

func httpLookupSponsor(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupSponsor")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.LookupSponsorRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupSponsorRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupSponsor(ctx, w, r, &payload)
}

func httpLookupTrack(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupTrack")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.LookupTrackRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupTrackRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupTrack(ctx, w, r, &payload)
}

func httpLookupUser(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupUser")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.LookupUserRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupUserRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupUser(ctx, w, r, &payload)
}

func httpLookupUserAvatar(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupUserAvatar")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.LookupUserAvatarRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupUserAvatarRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupUserAvatar(ctx, w, r, &payload)
}

func httpLookupUserByAuthUserID(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupUserByAuthUserID")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.LookupUserByAuthUserIDRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupUserByAuthUserIDRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupUserByAuthUserID(ctx, w, r, &payload)
}

func httpLookupVenue(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpLookupVenue")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `get` {
		w.Header().Set("Allow", "get")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'get'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	w.Header().Set(`Access-Control-Allow-Origin`, "*")
	var payload model.LookupVenueRequest
	qbuf := getBytesBuffer()
	defer releaseBytesBuffer(qbuf)
	qbuf.WriteString(r.URL.RawQuery)
	if err := urlenc.Unmarshal(qbuf.Bytes(), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupVenueRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doLookupVenue(ctx, w, r, &payload)
}

func httpSendAllSelectionResultNotification(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpSendAllSelectionResultNotification")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.SendAllSelectionResultNotificationRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPSendAllSelectionResultNotificationRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doSendAllSelectionResultNotification(ctx, w, r, &payload)
}

func httpSendSelectionResultNotification(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpSendSelectionResultNotification")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.SendSelectionResultNotificationRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPSendSelectionResultNotificationRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doSendSelectionResultNotification(ctx, w, r, &payload)
}

func httpSetSessionVideoCover(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpSetSessionVideoCover")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.SetSessionVideoCoverRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	case strings.HasPrefix(ct, "multipart/"):
		if err := r.ParseMultipartForm(MaxPostSize); err != nil {
			httpError(w, `Invalid multipart data`, http.StatusInternalServerError, err)
			return
		}
		vals, ok := r.MultipartForm.Value["payload"]
		if ok && len(vals) > 0 {
			if _, err := jsonbuf.WriteString(vals[0]); err != nil {
				httpError(w, `Failed to read payload`, http.StatusInternalServerError, err)
				return
			}
		}
		payload.MultipartForm = r.MultipartForm
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPSetSessionVideoCoverRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doSetSessionVideoCover(ctx, w, r, &payload)
}

func httpTweetAsConference(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpTweetAsConference")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.TweetAsConferenceRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPTweetAsConferenceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doTweetAsConference(ctx, w, r, &payload)
}

func httpUpdateBlogEntry(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateBlogEntry")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateBlogEntryRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateBlogEntryRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateBlogEntry(ctx, w, r, &payload)
}

func httpUpdateConference(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateConference")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateConferenceRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	case strings.HasPrefix(ct, "multipart/"):
		if err := r.ParseMultipartForm(MaxPostSize); err != nil {
			httpError(w, `Invalid multipart data`, http.StatusInternalServerError, err)
			return
		}
		vals, ok := r.MultipartForm.Value["payload"]
		if ok && len(vals) > 0 {
			if _, err := jsonbuf.WriteString(vals[0]); err != nil {
				httpError(w, `Failed to read payload`, http.StatusInternalServerError, err)
				return
			}
		}
		payload.MultipartForm = r.MultipartForm
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateConferenceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateConference(ctx, w, r, &payload)
}

func httpUpdateExternalResource(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateExternalResource")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateExternalResourceRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateExternalResourceRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateExternalResource(ctx, w, r, &payload)
}

func httpUpdateFeaturedSpeaker(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateFeaturedSpeaker")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateFeaturedSpeakerRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateFeaturedSpeakerRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateFeaturedSpeaker(ctx, w, r, &payload)
}

func httpUpdateRoom(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateRoom")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateRoomRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateRoomRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateRoom(ctx, w, r, &payload)
}

func httpUpdateSession(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateSession")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateSessionRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateSessionRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateSession(ctx, w, r, &payload)
}

func httpUpdateSessionType(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateSessionType")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateSessionTypeRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateSessionTypeRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateSessionType(ctx, w, r, &payload)
}

func httpUpdateSponsor(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateSponsor")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateSponsorRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateSponsorRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateSponsor(ctx, w, r, &payload)
}

func httpUpdateTrack(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateTrack")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateTrackRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateTrackRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateTrack(ctx, w, r, &payload)
}

func httpUpdateUser(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateUser")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateUserRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateUserRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateUser(ctx, w, r, &payload)
}

func httpUpdateVenue(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpUpdateVenue")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.UpdateVenueRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPUpdateVenueRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doUpdateVenue(ctx, w, r, &payload)
}

func httpVerifyUser(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	if pdebug.Enabled {
		g := pdebug.Marker("httpVerifyUser")
		defer g.End()
	}
	method := strings.ToLower(r.Method)
	if method != `post` {
		w.Header().Set("Allow", "post")
		msgbuf := getBytesBuffer()
		defer releaseBytesBuffer(msgbuf)
		msgbuf.WriteString(`Method was `)
		msgbuf.WriteString(r.Method)
		msgbuf.WriteString(`, expected 'post'`)
		httpError(w, msgbuf.String(), http.StatusNotFound, nil)
		return
	}

	var payload model.VerifyUserRequest
	jsonbuf := getBytesBuffer()
	defer releaseBytesBuffer(jsonbuf)

	switch ct := r.Header.Get("Content-Type"); {
	case ct == "application/json":
		if _, err := io.Copy(jsonbuf, io.LimitReader(r.Body, MaxPostSize)); err != nil {
			httpError(w, `Failed to read request body`, http.StatusInternalServerError, err)
			return
		}
	default:
		httpError(w, `Invalid content-type`, http.StatusInternalServerError, nil)
		return
	}
	if pdebug.Enabled {
		pdebug.Printf(`-----> %s`, jsonbuf.Bytes())
	}
	if err := json.Unmarshal(jsonbuf.Bytes(), &payload); err != nil {
		httpError(w, `Invalid JSON input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPVerifyUserRequest.Validate(&payload); err != nil {
		httpError(w, `Invalid input (validation failed)`, http.StatusInternalServerError, err)
		return
	}
	doVerifyUser(ctx, w, r, &payload)
}

func (s *Server) SetupRoutes() {
	r := s.Router
	r.HandleFunc(`/`, httpWithContext(httpHealthCheck))
	r.HandleFunc(`/v2/blog_entry/create`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpCreateBlogEntry))))
	r.HandleFunc(`/v2/blog_entry/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteBlogEntry))))
	r.HandleFunc(`/v2/blog_entry/list`, httpWithContext(httpListBlogEntries))
	r.HandleFunc(`/v2/blog_entry/lookup`, httpWithContext(httpLookupBlogEntry))
	r.HandleFunc(`/v2/blog_entry/update`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpUpdateBlogEntry))))
	r.HandleFunc(`/v2/client/session`, httpWithContext(httpWithBasicAuth(httpCreateClientSession)))
	r.HandleFunc(`/v2/conference/admin/add`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpAddConferenceAdmin))))
	r.HandleFunc(`/v2/conference/admin/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteConferenceAdmin))))
	r.HandleFunc(`/v2/conference/admin/list`, httpWithContext(httpWithBasicAuth(httpListConferenceAdmin)))
	r.HandleFunc(`/v2/conference/create`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpCreateConference))))
	r.HandleFunc(`/v2/conference/credentials/add`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpAddConferenceCredential))))
	r.HandleFunc(`/v2/conference/date/add`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpAddConferenceDate))))
	r.HandleFunc(`/v2/conference/date/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteConferenceDate))))
	r.HandleFunc(`/v2/conference/date/list`, httpWithContext(httpWithBasicAuth(httpListConferenceDate)))
	r.HandleFunc(`/v2/conference/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteConference))))
	r.HandleFunc(`/v2/conference/list`, httpWithContext(httpWithOptionalBasicAuth(httpListConference)))
	r.HandleFunc(`/v2/conference/list_by_organizer`, httpWithContext(httpWithOptionalBasicAuth(httpListConferencesByOrganizer)))
	r.HandleFunc(`/v2/conference/lookup`, httpWithContext(httpLookupConference))
	r.HandleFunc(`/v2/conference/lookup_by_slug`, httpWithContext(httpLookupConferenceBySlug))
	r.HandleFunc(`/v2/conference/schedule.ics`, httpWithContext(httpGetConferenceSchedule))
	r.HandleFunc(`/v2/conference/session_type/add`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpAddSessionType))))
	r.HandleFunc(`/v2/conference/staff/add`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpAddConferenceStaff))))
	r.HandleFunc(`/v2/conference/staff/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteConferenceStaff))))
	r.HandleFunc(`/v2/conference/staff/list`, httpWithContext(httpWithOptionalBasicAuth(httpListConferenceStaff)))
	r.HandleFunc(`/v2/conference/tweet`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpTweetAsConference))))
	r.HandleFunc(`/v2/conference/update`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpUpdateConference))))
	r.HandleFunc(`/v2/conference/venue/add`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpAddConferenceVenue))))
	r.HandleFunc(`/v2/conference/venue/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteConferenceVenue))))
	r.HandleFunc(`/v2/conference_series/admin/add`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpAddConferenceSeriesAdmin))))
	r.HandleFunc(`/v2/conference_series/create`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpCreateConferenceSeries))))
	r.HandleFunc(`/v2/conference_series/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteConferenceSeries))))
	r.HandleFunc(`/v2/conference_series/list`, httpWithContext(httpWithOptionalBasicAuth(httpListConferenceSeries)))
	r.HandleFunc(`/v2/conference_series/lookup`, httpWithContext(httpLookupConferenceSeries))
	r.HandleFunc(`/v2/email/confirm`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpConfirmTemporaryEmail))))
	r.HandleFunc(`/v2/email/create`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpCreateTemporaryEmail))))
	r.HandleFunc(`/v2/external_resource/create`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpCreateExternalResource))))
	r.HandleFunc(`/v2/external_resource/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteExternalResource))))
	r.HandleFunc(`/v2/external_resource/list`, httpWithContext(httpListExternalResource))
	r.HandleFunc(`/v2/external_resource/lookup`, httpWithContext(httpLookupExternalResource))
	r.HandleFunc(`/v2/external_resource/update`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpUpdateExternalResource))))
	r.HandleFunc(`/v2/featured_speaker/add`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpAddFeaturedSpeaker))))
	r.HandleFunc(`/v2/featured_speaker/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteFeaturedSpeaker))))
	r.HandleFunc(`/v2/featured_speaker/list`, httpWithContext(httpWithOptionalBasicAuth(httpListFeaturedSpeakers)))
	r.HandleFunc(`/v2/featured_speaker/lookup`, httpWithContext(httpWithBasicAuth(httpLookupFeaturedSpeaker)))
	r.HandleFunc(`/v2/featured_speaker/update`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpUpdateFeaturedSpeaker))))
	r.HandleFunc(`/v2/question/create`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpCreateQuestion))))
	r.HandleFunc(`/v2/question/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteQuestion))))
	r.HandleFunc(`/v2/question/list`, httpWithContext(httpWithOptionalBasicAuth(httpListQuestion)))
	r.HandleFunc(`/v2/room/create`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpCreateRoom))))
	r.HandleFunc(`/v2/room/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteRoom))))
	r.HandleFunc(`/v2/room/list`, httpWithContext(httpWithOptionalBasicAuth(httpListRoom)))
	r.HandleFunc(`/v2/room/lookup`, httpWithContext(httpLookupRoom))
	r.HandleFunc(`/v2/room/update`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpUpdateRoom))))
	r.HandleFunc(`/v2/session/create`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpCreateSession))))
	r.HandleFunc(`/v2/session/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteSession))))
	r.HandleFunc(`/v2/session/list`, httpWithContext(httpWithOptionalBasicAuth(httpListSessions)))
	r.HandleFunc(`/v2/session/lookup`, httpWithContext(httpWithOptionalBasicAuth(httpLookupSession)))
	r.HandleFunc(`/v2/session/send_all_selection_result_notification`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpSendAllSelectionResultNotification))))
	r.HandleFunc(`/v2/session/send_selection_result_notification`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpSendSelectionResultNotification))))
	r.HandleFunc(`/v2/session/update`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpUpdateSession))))
	r.HandleFunc(`/v2/session/video_cover`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpSetSessionVideoCover))))
	r.HandleFunc(`/v2/session_type/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteSessionType))))
	r.HandleFunc(`/v2/session_type/list`, httpWithContext(httpWithOptionalBasicAuth(httpListSessionTypesByConference)))
	r.HandleFunc(`/v2/session_type/lookup`, httpWithContext(httpWithOptionalBasicAuth(httpLookupSessionType)))
	r.HandleFunc(`/v2/session_type/update`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpUpdateSessionType))))
	r.HandleFunc(`/v2/sponsor/add`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpAddSponsor))))
	r.HandleFunc(`/v2/sponsor/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteSponsor))))
	r.HandleFunc(`/v2/sponsor/list`, httpWithContext(httpWithOptionalBasicAuth(httpListSponsors)))
	r.HandleFunc(`/v2/sponsor/lookup`, httpWithContext(httpWithOptionalBasicAuth(httpLookupSponsor)))
	r.HandleFunc(`/v2/sponsor/update`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpUpdateSponsor))))
	r.HandleFunc(`/v2/survey_session_response/create`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpCreateSessionSurveyResponse))))
	r.HandleFunc(`/v2/track/create`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpCreateTrack))))
	r.HandleFunc(`/v2/track/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteTrack))))
	r.HandleFunc(`/v2/track/lookup`, httpWithContext(httpLookupTrack))
	r.HandleFunc(`/v2/track/update`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpUpdateTrack))))
	r.HandleFunc(`/v2/user/avatar`, httpWithContext(httpLookupUserAvatar))
	r.HandleFunc(`/v2/user/create`, httpWithContext(httpWithBasicAuth(httpCreateUser)))
	r.HandleFunc(`/v2/user/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteUser))))
	r.HandleFunc(`/v2/user/list`, httpWithContext(httpWithOptionalBasicAuth(httpListUser)))
	r.HandleFunc(`/v2/user/lookup`, httpWithContext(httpWithOptionalBasicAuth(httpLookupUser)))
	r.HandleFunc(`/v2/user/lookup_user_by_auth_user_id`, httpWithContext(httpWithOptionalBasicAuth(httpLookupUserByAuthUserID)))
	r.HandleFunc(`/v2/user/update`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpUpdateUser))))
	r.HandleFunc(`/v2/user/verify`, httpWithContext(httpWithBasicAuth(httpVerifyUser)))
	r.HandleFunc(`/v2/venue/create`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpCreateVenue))))
	r.HandleFunc(`/v2/venue/delete`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpDeleteVenue))))
	r.HandleFunc(`/v2/venue/list`, httpWithContext(httpWithOptionalBasicAuth(httpListVenue)))
	r.HandleFunc(`/v2/venue/lookup`, httpWithContext(httpLookupVenue))
	r.HandleFunc(`/v2/venue/update`, httpWithContext(httpWithBasicAuth(httpWithClientSession(httpUpdateVenue))))
}
