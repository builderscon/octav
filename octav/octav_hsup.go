// DO NOT EDIT. Automatically generated by hsup at Wed, 09 Mar 2016 10:06:24 JST
package octav

import (
	"encoding/json"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/builderscon/octav/octav/validator"
	"github.com/gorilla/mux"
	"github.com/lestrrat/go-pdebug"
	"github.com/lestrrat/go-urlenc"
	"golang.org/x/net/context"
)

type Server struct {
	*mux.Router
}

func Run(l string) error {
	return http.ListenAndServe(l, New())
}

func New() *Server {
	s := &Server{
		Router: mux.NewRouter(),
	}
	s.SetupRoutes()
	return s
}

func httpError(w http.ResponseWriter, message string, st int, err error) {
	if pdebug.Enabled {
		if err == nil {
			pdebug.Printf("HTTP Error %s", message)
		} else {
			pdebug.Printf("HTTP Error %s: %s", message, err)
		}
	}
	http.Error(w, http.StatusText(st), st)
}

func getInteger(v url.Values, f string) ([]int64, error) {
	x, ok := v[f]
	if !ok {
		return nil, nil
	}

	ret := make([]int64, len(x))
	for i, e := range x {
		p, err := strconv.ParseInt(e, 10, 64)
		if err != nil {
			return nil, err
		}
		ret[i] = p
	}

	return ret, nil
}

func httpCreateConference(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `post` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	var payload CreateConferenceRequest
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateConferenceRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doCreateConference(context.Background(), w, r, payload)
}

func httpCreateRoom(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `post` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	var payload Room
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateRoomRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doCreateRoom(context.Background(), w, r, payload)
}

func httpCreateSession(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `post` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	var payload interface{}
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateSessionRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doCreateSession(context.Background(), w, r, payload)
}

func httpCreateUser(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `post` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	var payload CreateUserRequest
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateUserRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doCreateUser(context.Background(), w, r, payload)
}

func httpCreateVenue(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `post` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	var payload Venue
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPCreateVenueRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doCreateVenue(context.Background(), w, r, payload)
}

func httpDeleteConference(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `post` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	var payload DeleteConferenceRequest
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteConferenceRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doDeleteConference(context.Background(), w, r, payload)
}

func httpDeleteRoom(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `post` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	var payload DeleteRoomRequest
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteRoomRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doDeleteRoom(context.Background(), w, r, payload)
}

func httpDeleteUser(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `post` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	var payload DeleteUserRequest
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteUserRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doDeleteUser(context.Background(), w, r, payload)
}

func httpDeleteVenue(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `post` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	var payload DeleteVenueRequest
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPDeleteVenueRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doDeleteVenue(context.Background(), w, r, payload)
}

func httpListRooms(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `get` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	var payload ListRoomRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListRoomsRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doListRooms(context.Background(), w, r, payload)
}

func httpListSessionsByConference(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `get` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	if err := r.ParseForm(); err != nil {
		httpError(w, `Failed to process query/post form`, http.StatusInternalServerError, nil)
		return
	}
	payload := make(map[string]interface{})
	{
		v := r.Form["conference_id"]
		switch len(v) {
		case 0:
		case 1:
			payload["conference_id"] = v[0]
		default:
			payload["conference_id"] = v
		}
	}

	{
		v := r.Form["date"]
		switch len(v) {
		case 0:
		case 1:
			payload["date"] = v[0]
		default:
			payload["date"] = v
		}
	}

	if err := validator.HTTPListSessionsByConferenceRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doListSessionsByConference(context.Background(), w, r, payload)
}

func httpListVenues(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `get` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	var payload ListVenueRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPListVenuesRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doListVenues(context.Background(), w, r, payload)
}

func httpLookupConference(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `get` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	var payload LookupConferenceRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupConferenceRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doLookupConference(context.Background(), w, r, payload)
}

func httpLookupRoom(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `get` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	var payload LookupRoomRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupRoomRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doLookupRoom(context.Background(), w, r, payload)
}

func httpLookupSession(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `get` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	if err := r.ParseForm(); err != nil {
		httpError(w, `Failed to process query/post form`, http.StatusInternalServerError, nil)
		return
	}
	payload := make(map[string]interface{})
	{
		v := r.Form["id"]
		switch len(v) {
		case 0:
		case 1:
			payload["id"] = v[0]
		default:
			payload["id"] = v
		}
	}

	if err := validator.HTTPLookupSessionRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doLookupSession(context.Background(), w, r, payload)
}

func httpLookupUser(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `get` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	var payload LookupUserRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupUserRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doLookupUser(context.Background(), w, r, payload)
}

func httpLookupVenue(w http.ResponseWriter, r *http.Request) {
	if strings.ToLower(r.Method) != `get` {
		httpError(w, `Method was `+r.Method, http.StatusNotFound, nil)
	}

	var payload LookupVenueRequest
	if err := urlenc.Unmarshal([]byte(r.URL.RawQuery), &payload); err != nil {
		httpError(w, `Failed to parse url query string`, http.StatusInternalServerError, err)
		return
	}

	if err := validator.HTTPLookupVenueRequest.Validate(payload); err != nil {
		httpError(w, `Invalid input`, http.StatusInternalServerError, err)
		return
	}
	doLookupVenue(context.Background(), w, r, payload)
}

func (s *Server) SetupRoutes() {
	r := s.Router
	r.HandleFunc(`/v1/conference/create`, httpCreateConference)
	r.HandleFunc(`/v1/conference/delete`, httpDeleteConference)
	r.HandleFunc(`/v1/conference/lookup`, httpLookupConference)
	r.HandleFunc(`/v1/room/create`, httpCreateRoom)
	r.HandleFunc(`/v1/room/delete`, httpDeleteRoom)
	r.HandleFunc(`/v1/room/list`, httpListRooms)
	r.HandleFunc(`/v1/room/lookup`, httpLookupRoom)
	r.HandleFunc(`/v1/schedule/list`, httpListSessionsByConference)
	r.HandleFunc(`/v1/session/create`, httpCreateSession)
	r.HandleFunc(`/v1/session/lookup`, httpLookupSession)
	r.HandleFunc(`/v1/user/create`, httpCreateUser)
	r.HandleFunc(`/v1/user/delete`, httpDeleteUser)
	r.HandleFunc(`/v1/user/lookup`, httpLookupUser)
	r.HandleFunc(`/v1/venue/create`, httpCreateVenue)
	r.HandleFunc(`/v1/venue/delete`, httpDeleteVenue)
	r.HandleFunc(`/v1/venue/list`, httpListVenues)
	r.HandleFunc(`/v1/venue/lookup`, httpLookupVenue)
}
