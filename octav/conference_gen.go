// Automatically generated by genmodel utility. DO NOT EDIT!
package octav

import (
	"encoding/json"
	"time"

	"github.com/builderscon/octav/octav/db"
	"github.com/builderscon/octav/octav/tools"
	"github.com/lestrrat/go-pdebug"
)

var _ = time.Time{}

func (v Conference) GetPropNames() ([]string, error) {
	l, _ := v.L10N.GetPropNames()
	return append(l, "id", "title", "sub_title", "slug"), nil
}

func (v Conference) GetPropValue(s string) (interface{}, error) {
	switch s {
	case "id":
		return v.ID, nil
	case "title":
		return v.Title, nil
	case "sub_title":
		return v.SubTitle, nil
	case "slug":
		return v.Slug, nil
	default:
		return v.L10N.GetPropValue(s)
	}
}

func (v Conference) MarshalJSON() ([]byte, error) {
	m := make(map[string]interface{})
	m["id"] = v.ID
	m["title"] = v.Title
	m["sub_title"] = v.SubTitle
	m["slug"] = v.Slug
	buf, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	return tools.MarshalJSONWithL10N(buf, v.L10N)
}

func (v *Conference) UnmarshalJSON(data []byte) error {
	m := make(map[string]interface{})
	if err := json.Unmarshal(data, &m); err != nil {
		return err
	}

	if jv, ok := m["id"]; ok {
		switch jv.(type) {
		case string:
			v.ID = jv.(string)
			delete(m, "id")
		default:
			return ErrInvalidFieldType{Field: "id"}
		}
	}

	if jv, ok := m["title"]; ok {
		switch jv.(type) {
		case string:
			v.Title = jv.(string)
			delete(m, "title")
		default:
			return ErrInvalidFieldType{Field: "title"}
		}
	}

	if jv, ok := m["sub_title"]; ok {
		switch jv.(type) {
		case string:
			v.SubTitle = jv.(string)
			delete(m, "sub_title")
		default:
			return ErrInvalidFieldType{Field: "sub_title"}
		}
	}

	if jv, ok := m["slug"]; ok {
		switch jv.(type) {
		case string:
			v.Slug = jv.(string)
			delete(m, "slug")
		default:
			return ErrInvalidFieldType{Field: "slug"}
		}
	}

	if err := tools.ExtractL10NFields(m, &v.L10N, []string{"title", "sub_title"}); err != nil {
		return err
	}
	return nil
}

func (v *Conference) Load(tx *db.Tx, id string) error {
	vdb := db.Conference{}
	if err := vdb.LoadByEID(tx, id); err != nil {
		return err
	}

	if err := v.FromRow(vdb); err != nil {
		return err
	}
	if err := v.LoadLocalizedFields(tx); err != nil {
		return err
	}
	return nil
}

func (v *Conference) LoadLocalizedFields(tx *db.Tx) error {
	ls, err := db.LoadLocalizedStringsForParent(tx, v.ID, "Conference")
	if err != nil {
		return err
	}

	if len(ls) > 0 {
		v.L10N = tools.LocalizedFields{}
		for _, l := range ls {
			v.L10N.Set(l.Language, l.Name, l.Localized)
		}
	}
	return nil
}

func (v *Conference) FromRow(vdb db.Conference) error {
	v.ID = vdb.EID
	v.Title = vdb.Title
	if vdb.SubTitle.Valid {
		v.SubTitle = vdb.SubTitle.String
	}
	v.Slug = vdb.Slug
	return nil
}

func (v *Conference) ToRow(vdb *db.Conference) error {
	vdb.EID = v.ID
	vdb.Title = v.Title
	vdb.SubTitle.Valid = true
	vdb.SubTitle.String = v.SubTitle
	vdb.Slug = v.Slug
	return nil
}

func (v *Conference) Update(tx *db.Tx) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("Conference.Update (%s)", v.ID).BindError(&err)
		defer g.End()
	}

	vdb := db.Conference{}
	v.ToRow(&vdb)
	if err := vdb.Update(tx); err != nil {
		return err
	}

	return v.L10N.Foreach(func(l, k, x string) error {
		ls := db.LocalizedString{
			ParentType: "Conference",
			ParentID:   v.ID,
			Language:   l,
			Name:       k,
			Localized:  x,
		}
		return ls.Upsert(tx)
	})
}

func (v *Conference) Delete(tx *db.Tx) error {
	if pdebug.Enabled {
		g := pdebug.Marker("Conference.Delete (%s)", v.ID)
		defer g.End()
	}

	vdb := db.Conference{EID: v.ID}
	if err := vdb.Delete(tx); err != nil {
		return err
	}
	if err := db.DeleteLocalizedStringsForParent(tx, v.ID, "Conference"); err != nil {
		return err
	}
	return nil
}

func (v *ConferenceList) Load(tx *db.Tx, since string, limit int) error {
	vdbl := db.ConferenceList{}
	if err := vdbl.LoadSinceEID(tx, since, limit); err != nil {
		return err
	}
	res := make([]Conference, len(vdbl))
	for i, vdb := range vdbl {
		v := Conference{}
		if err := v.FromRow(vdb); err != nil {
			return err
		}
		if err := v.LoadLocalizedFields(tx); err != nil {
			return err
		}
		res[i] = v
	}
	*v = res
	return nil
}
