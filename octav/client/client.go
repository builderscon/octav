// DO NOT EDIT. Automatically generated by hsup
package client

import (
	"bytes"
	"encoding/json"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"os"
	"strings"
	"sync"

	"github.com/builderscon/octav/octav/model"
	"github.com/lestrrat/go-pdebug"
	"github.com/lestrrat/go-urlenc"
	"github.com/pkg/errors"
)

const MaxResponseSize = (1 << 20) * 2

var _ = bytes.MinRead
var _ = json.Decoder{}
var _ = multipart.Form{}
var _ = os.Stdout
var transportJSONBufferPool = sync.Pool{
	New: allocTransportJSONBuffer,
}

func allocTransportJSONBuffer() interface{} {
	return &bytes.Buffer{}
}

func getTransportJSONBuffer() *bytes.Buffer {
	return transportJSONBufferPool.Get().(*bytes.Buffer)
}

func releaseTransportJSONBuffer(buf *bytes.Buffer) {
	buf.Reset()
	transportJSONBufferPool.Put(buf)
}

type BasicAuth struct {
	Username string
	Password string
}

type ErrJSON struct {
	Error string `json:"error,omitempty"`
}

type Client struct {
	BasicAuth BasicAuth
	Client    *http.Client
	Endpoint  string
}

func New(s string) *Client {
	return &Client{
		Client:   &http.Client{},
		Endpoint: s,
	}
}

func (c *Client) AddConferenceAdmin(in *model.AddConferenceAdminRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.AddConferenceAdmin").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/admin/add")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) AddConferenceCredential(in *model.AddConferenceCredentialRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.AddConferenceCredential").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/credentials/add")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) AddConferenceDate(in *model.CreateConferenceDateRequest) (ret *model.ConferenceDate, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.AddConferenceDate").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/date/add")
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return nil, err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.ConferenceDate
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) AddConferenceSeriesAdmin(in *model.AddConferenceSeriesAdminRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.AddConferenceSeriesAdmin").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference_series/admin/add")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) AddConferenceVenue(in *model.AddConferenceVenueRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.AddConferenceVenue").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/venue/add")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) AddFeaturedSpeaker(in *model.AddFeaturedSpeakerRequest) (ret *model.FeaturedSpeaker, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.AddFeaturedSpeaker").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/featured_speaker/add")
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return nil, err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.FeaturedSpeaker
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) AddSessionType(in *model.AddSessionTypeRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.AddSessionType").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/session_type/add")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) AddSponsor(in *model.AddSponsorRequest) (ret *model.Sponsor, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.AddSponsor").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/sponsor/add")
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return nil, err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.Sponsor
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) ConfirmTemporaryEmail(in *model.ConfirmTemporaryEmailRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.ConfirmTemporaryEmail").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/email/confirm")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) CreateConference(in *model.CreateConferenceRequest) (ret *model.ObjectID, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.CreateConference").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/create")
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return nil, err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.ObjectID
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) CreateConferenceSeries(in *model.CreateConferenceSeriesRequest) (ret *model.ObjectID, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.CreateConferenceSeries").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference_series/create")
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return nil, err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.ObjectID
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) CreateQuestion(in *model.CreateQuestionRequest) (ret *model.ObjectID, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.CreateQuestion").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/question/create")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.ObjectID
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) CreateRoom(in *model.CreateRoomRequest) (ret *model.ObjectID, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.CreateRoom").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/room/create")
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return nil, err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.ObjectID
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) CreateSession(in *model.CreateSessionRequest) (ret *model.ObjectID, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.CreateSession").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/session/create")
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return nil, err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.ObjectID
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) CreateSessionSurveyResponse(in *model.CreateSessionSurveyResponseRequest) (ret *model.ObjectID, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.CreateSessionSurveyResponse").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/survey_session_response/create")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.ObjectID
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) CreateTemporaryEmail(in *model.CreateTemporaryEmailRequest) (ret *model.CreateTemporaryEmailResponse, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.CreateTemporaryEmail").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/email/create")
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return nil, err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.CreateTemporaryEmailResponse
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) CreateUser(in *model.CreateUserRequest) (ret *model.User, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.CreateUser").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/user/create")
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return nil, err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.User
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) CreateVenue(in *model.CreateVenueRequest) (ret *model.ObjectID, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.CreateVenue").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/venue/create")
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return nil, err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.ObjectID
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) DeleteConference(in *model.DeleteConferenceRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.DeleteConference").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/delete")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) DeleteConferenceAdmin(in *model.DeleteConferenceAdminRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.DeleteConferenceAdmin").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/admin/delete")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) DeleteConferenceDate(in *model.DeleteConferenceDateRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.DeleteConferenceDate").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/date/delete")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) DeleteConferenceSeries(in *model.DeleteConferenceSeriesRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.DeleteConferenceSeries").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference_series/delete")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) DeleteConferenceVenue(in *model.DeleteConferenceVenueRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.DeleteConferenceVenue").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/venue/delete")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) DeleteFeaturedSpeaker(in *model.DeleteFeaturedSpeakerRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.DeleteFeaturedSpeaker").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/featured_speaker/delete")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) DeleteQuestion(in *model.DeleteQuestionRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.DeleteQuestion").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/question/delete")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) DeleteRoom(in *model.DeleteRoomRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.DeleteRoom").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/room/delete")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) DeleteSession(in *model.DeleteSessionRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.DeleteSession").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/session/delete")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) DeleteSessionType(in *model.DeleteSessionTypeRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.DeleteSessionType").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/session_type/delete")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) DeleteSponsor(in *model.DeleteSponsorRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.DeleteSponsor").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/sponsor/delete")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) DeleteUser(in *model.DeleteUserRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.DeleteUser").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/user/delete")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) DeleteVenue(in *model.DeleteVenueRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.DeleteVenue").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/venue/delete")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) GetConferenceSchedule(in *model.GetConferenceScheduleRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.GetConferenceSchedule").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/schedule.ics")
	if err != nil {
		return err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) HealthCheck() (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.HealthCheck").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/")
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) ListConference(in *model.ListConferenceRequest) (ret []model.Conference, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.ListConference").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/list")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload []model.Conference
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return payload, nil
}

func (c *Client) ListConferenceAdmin(in *model.ListConferenceAdminRequest) (ret []model.User, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.ListConferenceAdmin").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/admin/list")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload []model.User
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return payload, nil
}

func (c *Client) ListConferenceSeries(in *model.ListConferenceSeriesRequest) (ret []model.ConferenceSeries, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.ListConferenceSeries").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference_series/list")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload []model.ConferenceSeries
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return payload, nil
}

func (c *Client) ListConferencesByOrganizer(in *model.ListConferencesByOrganizerRequest) (ret []model.Conference, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.ListConferencesByOrganizer").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/list_by_organizer")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload []model.Conference
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return payload, nil
}

func (c *Client) ListFeaturedSpeakers(in *model.ListFeaturedSpeakersRequest) (ret []model.FeaturedSpeaker, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.ListFeaturedSpeakers").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/featured_speaker/list")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload []model.FeaturedSpeaker
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return payload, nil
}

func (c *Client) ListQuestion(in *model.ListQuestionRequest) (ret []model.Question, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.ListQuestion").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/question/list")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload []model.Question
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return payload, nil
}

func (c *Client) ListRoom(in *model.ListRoomRequest) (ret []model.Room, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.ListRoom").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/room/list")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload []model.Room
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return payload, nil
}

func (c *Client) ListSessionTypesByConference(in *model.ListSessionTypesByConferenceRequest) (ret []model.SessionType, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.ListSessionTypesByConference").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/session_type/list")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload []model.SessionType
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return payload, nil
}

func (c *Client) ListSessions(in *model.ListSessionsRequest) (ret []model.Session, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.ListSessions").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/session/list")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload []model.Session
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return payload, nil
}

func (c *Client) ListSponsors(in *model.ListSponsorsRequest) (ret []model.Sponsor, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.ListSponsors").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/sponsor/list")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload []model.Sponsor
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return payload, nil
}

func (c *Client) ListUser(in *model.ListUserRequest) (ret []model.User, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.ListUser").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/user/list")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload []model.User
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return payload, nil
}

func (c *Client) ListVenue(in *model.ListVenueRequest) (ret []model.Venue, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.ListVenue").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/venue/list")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload []model.Venue
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return payload, nil
}

func (c *Client) LookupConference(in *model.LookupConferenceRequest) (ret *model.Conference, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.LookupConference").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/lookup")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.Conference
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) LookupConferenceBySlug(in *model.LookupConferenceBySlugRequest) (ret *model.Conference, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.LookupConferenceBySlug").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/lookup_by_slug")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.Conference
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) LookupConferenceSeries(in *model.LookupConferenceSeriesRequest) (ret *model.ConferenceSeries, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.LookupConferenceSeries").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference_series/lookup")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.ConferenceSeries
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) LookupFeaturedSpeaker(in *model.LookupFeaturedSpeakerRequest) (ret *model.FeaturedSpeaker, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.LookupFeaturedSpeaker").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/featured_speaker/lookup")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.FeaturedSpeaker
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) LookupRoom(in *model.LookupRoomRequest) (ret *model.Room, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.LookupRoom").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/room/lookup")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.Room
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) LookupSession(in *model.LookupSessionRequest) (ret *model.Session, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.LookupSession").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/session/lookup")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.Session
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) LookupSessionType(in *model.LookupSessionTypeRequest) (ret *model.SessionType, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.LookupSessionType").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/session_type/lookup")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.SessionType
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) LookupSponsor(in *model.LookupSponsorRequest) (ret *model.Sponsor, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.LookupSponsor").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/sponsor/lookup")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.Sponsor
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) LookupUser(in *model.LookupUserRequest) (ret *model.User, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.LookupUser").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/user/lookup")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.User
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) LookupUserByAuthUserID(in *model.LookupUserByAuthUserIDRequest) (ret *model.User, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.LookupUserByAuthUserID").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/user/lookup_user_by_auth_user_id")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.User
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) LookupVenue(in *model.LookupVenueRequest) (ret *model.Venue, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.LookupVenue").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/venue/lookup")
	if err != nil {
		return nil, err
	}
	buf, err := urlenc.Marshal(in)
	if err != nil {
		return nil, err
	}
	u.RawQuery = string(buf)
	if pdebug.Enabled {
		pdebug.Printf("GET to %s", u.String())
	}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.Venue
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) SendAllSelectionResultNotification(in *model.SendAllSelectionResultNotificationRequest) (ret *model.SendAllSelectionResultNotificationResponse, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.SendAllSelectionResultNotification").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/session/send_all_selection_result_notification")
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return nil, err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.SendAllSelectionResultNotificationResponse
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) SendSelectionResultNotification(in *model.SendSelectionResultNotificationRequest) (ret *model.SendSelectionResultNotificationResponse, err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.SendSelectionResultNotification").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/session/send_selection_result_notification")
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return nil, err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return nil, errors.New(errjson.Error)
			}
		}
		return nil, errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	jsonbuf := getTransportJSONBuffer()
	defer releaseTransportJSONBuffer(jsonbuf)
	_, err = io.Copy(jsonbuf, io.LimitReader(res.Body, MaxResponseSize))
	defer res.Body.Close()
	if pdebug.Enabled {
		if err != nil {
			pdebug.Printf("failed to read respons buffer: %s", err)
		} else {
			pdebug.Printf("response buffer: %s", jsonbuf)
		}
	}
	if err != nil {
		return nil, err
	}

	var payload model.SendSelectionResultNotificationResponse
	err = json.Unmarshal(jsonbuf.Bytes(), &payload)
	if err != nil {
		return nil, err
	}
	return &payload, nil
}

func (c *Client) TweetAsConference(in *model.TweetAsConferenceRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.TweetAsConference").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/tweet")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) UpdateConference(in *model.UpdateConferenceRequest, files map[string]string) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.UpdateConference").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/conference/update")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	w := multipart.NewWriter(&buf)
	var jsbuf bytes.Buffer
	err = json.NewEncoder(&jsbuf).Encode(in)
	if err != nil {
		return err
	}
	w.WriteField("payload", jsbuf.String())
	if fn, ok := files["cover"]; ok {
		fw, err := w.CreateFormFile("cover", fn)
		if err != nil {
			return err
		}
		f, err := os.Open(fn)
		if err != nil {
			return err
		}
		defer f.Close()
		_, err = io.Copy(fw, f)
		if err != nil {
			return err
		}
	}
	err = w.Close()
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) UpdateFeaturedSpeaker(in *model.UpdateFeaturedSpeakerRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.UpdateFeaturedSpeaker").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/featured_speaker/update")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) UpdateRoom(in *model.UpdateRoomRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.UpdateRoom").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/room/update")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) UpdateSession(in *model.UpdateSessionRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.UpdateSession").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/session/update")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) UpdateSessionType(in *model.UpdateSessionTypeRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.UpdateSessionType").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/session_type/update")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) UpdateSponsor(in *model.UpdateSponsorRequest, files map[string]string) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.UpdateSponsor").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/sponsor/update")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	w := multipart.NewWriter(&buf)
	var jsbuf bytes.Buffer
	err = json.NewEncoder(&jsbuf).Encode(in)
	if err != nil {
		return err
	}
	w.WriteField("payload", jsbuf.String())
	if fn, ok := files["logo1"]; ok {
		fw, err := w.CreateFormFile("logo1", fn)
		if err != nil {
			return err
		}
		f, err := os.Open(fn)
		if err != nil {
			return err
		}
		defer f.Close()
		_, err = io.Copy(fw, f)
		if err != nil {
			return err
		}
	}
	if fn, ok := files["logo2"]; ok {
		fw, err := w.CreateFormFile("logo2", fn)
		if err != nil {
			return err
		}
		f, err := os.Open(fn)
		if err != nil {
			return err
		}
		defer f.Close()
		_, err = io.Copy(fw, f)
		if err != nil {
			return err
		}
	}
	if fn, ok := files["logo3"]; ok {
		fw, err := w.CreateFormFile("logo3", fn)
		if err != nil {
			return err
		}
		f, err := os.Open(fn)
		if err != nil {
			return err
		}
		defer f.Close()
		_, err = io.Copy(fw, f)
		if err != nil {
			return err
		}
	}
	err = w.Close()
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) UpdateUser(in *model.UpdateUserRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.UpdateUser").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/user/update")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) UpdateVenue(in *model.UpdateVenueRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.UpdateVenue").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/venue/update")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}

func (c *Client) VerifyUser(in *model.VerifyUserRequest) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("client.VerifyUser").BindError(&err)
		defer g.End()
	}
	u, err := url.Parse(c.Endpoint + "/v1/user/verify")
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	err = json.NewEncoder(&buf).Encode(in)
	if err != nil {
		return err
	}
	if pdebug.Enabled {
		pdebug.Printf("POST to %s", u.String())
		pdebug.Printf("%s", buf.String())
	}
	req, err := http.NewRequest("POST", u.String(), &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if c.BasicAuth.Username != "" && c.BasicAuth.Password != "" {
		req.SetBasicAuth(c.BasicAuth.Username, c.BasicAuth.Password)
	}
	res, err := c.Client.Do(req)
	if err != nil {
		return err
	}
	if res.StatusCode != http.StatusOK {
		if strings.HasPrefix(strings.ToLower(res.Header.Get(`Content-Type`)), `application/json`) {
			var errjson ErrJSON
			if err := json.NewDecoder(res.Body).Decode(&errjson); err != nil {
				return errors.Errorf(`Invalid response: '%s'`, res.Status)
			}
			if len(errjson.Error) > 0 {
				return errors.New(errjson.Error)
			}
		}
		return errors.Errorf(`Invalid response: '%s'`, res.Status)
	}
	return nil
}
